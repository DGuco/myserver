// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: player.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_player_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_player_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_player_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_player_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_player_2eproto;
class ChangeNameRequest;
struct ChangeNameRequestDefaultTypeInternal;
extern ChangeNameRequestDefaultTypeInternal _ChangeNameRequest_default_instance_;
class ChangeNameResponse;
struct ChangeNameResponseDefaultTypeInternal;
extern ChangeNameResponseDefaultTypeInternal _ChangeNameResponse_default_instance_;
class GuideDTO;
struct GuideDTODefaultTypeInternal;
extern GuideDTODefaultTypeInternal _GuideDTO_default_instance_;
class GuidePush;
struct GuidePushDefaultTypeInternal;
extern GuidePushDefaultTypeInternal _GuidePush_default_instance_;
class PlayeBattlePush;
struct PlayeBattlePushDefaultTypeInternal;
extern PlayeBattlePushDefaultTypeInternal _PlayeBattlePush_default_instance_;
class PlayerCount;
struct PlayerCountDefaultTypeInternal;
extern PlayerCountDefaultTypeInternal _PlayerCount_default_instance_;
class PlayerCountPush;
struct PlayerCountPushDefaultTypeInternal;
extern PlayerCountPushDefaultTypeInternal _PlayerCountPush_default_instance_;
class PlayerDTO;
struct PlayerDTODefaultTypeInternal;
extern PlayerDTODefaultTypeInternal _PlayerDTO_default_instance_;
class PlayerDataPush;
struct PlayerDataPushDefaultTypeInternal;
extern PlayerDataPushDefaultTypeInternal _PlayerDataPush_default_instance_;
class PlayerHeartBeatRequest;
struct PlayerHeartBeatRequestDefaultTypeInternal;
extern PlayerHeartBeatRequestDefaultTypeInternal _PlayerHeartBeatRequest_default_instance_;
class PlayerHeartBeatResponse;
struct PlayerHeartBeatResponseDefaultTypeInternal;
extern PlayerHeartBeatResponseDefaultTypeInternal _PlayerHeartBeatResponse_default_instance_;
class PlayerLevelUpPush;
struct PlayerLevelUpPushDefaultTypeInternal;
extern PlayerLevelUpPushDefaultTypeInternal _PlayerLevelUpPush_default_instance_;
class PlayerLoginRequest;
struct PlayerLoginRequestDefaultTypeInternal;
extern PlayerLoginRequestDefaultTypeInternal _PlayerLoginRequest_default_instance_;
class PlayerLoginResponse;
struct PlayerLoginResponseDefaultTypeInternal;
extern PlayerLoginResponseDefaultTypeInternal _PlayerLoginResponse_default_instance_;
class PlayerPropertyChangePush;
struct PlayerPropertyChangePushDefaultTypeInternal;
extern PlayerPropertyChangePushDefaultTypeInternal _PlayerPropertyChangePush_default_instance_;
class PlayerProtectPush;
struct PlayerProtectPushDefaultTypeInternal;
extern PlayerProtectPushDefaultTypeInternal _PlayerProtectPush_default_instance_;
class PlayerReconnectRequest;
struct PlayerReconnectRequestDefaultTypeInternal;
extern PlayerReconnectRequestDefaultTypeInternal _PlayerReconnectRequest_default_instance_;
class PlayerReconnectResponse;
struct PlayerReconnectResponseDefaultTypeInternal;
extern PlayerReconnectResponseDefaultTypeInternal _PlayerReconnectResponse_default_instance_;
class PlayerReloadRequest;
struct PlayerReloadRequestDefaultTypeInternal;
extern PlayerReloadRequestDefaultTypeInternal _PlayerReloadRequest_default_instance_;
class PlayerReloadResponse;
struct PlayerReloadResponseDefaultTypeInternal;
extern PlayerReloadResponseDefaultTypeInternal _PlayerReloadResponse_default_instance_;
class QueryLordInfoRequest;
struct QueryLordInfoRequestDefaultTypeInternal;
extern QueryLordInfoRequestDefaultTypeInternal _QueryLordInfoRequest_default_instance_;
class QueryLordInfoResponse;
struct QueryLordInfoResponseDefaultTypeInternal;
extern QueryLordInfoResponseDefaultTypeInternal _QueryLordInfoResponse_default_instance_;
class SetGuideRequest;
struct SetGuideRequestDefaultTypeInternal;
extern SetGuideRequestDefaultTypeInternal _SetGuideRequest_default_instance_;
class SetIconRequest;
struct SetIconRequestDefaultTypeInternal;
extern SetIconRequestDefaultTypeInternal _SetIconRequest_default_instance_;
class SetIconResponse;
struct SetIconResponseDefaultTypeInternal;
extern SetIconResponseDefaultTypeInternal _SetIconResponse_default_instance_;
class SetImageRequest;
struct SetImageRequestDefaultTypeInternal;
extern SetImageRequestDefaultTypeInternal _SetImageRequest_default_instance_;
class SetImageResponse;
struct SetImageResponseDefaultTypeInternal;
extern SetImageResponseDefaultTypeInternal _SetImageResponse_default_instance_;
class SetTalentRequest;
struct SetTalentRequestDefaultTypeInternal;
extern SetTalentRequestDefaultTypeInternal _SetTalentRequest_default_instance_;
class SetTalentResponse;
struct SetTalentResponseDefaultTypeInternal;
extern SetTalentResponseDefaultTypeInternal _SetTalentResponse_default_instance_;
class SysTimePush;
struct SysTimePushDefaultTypeInternal;
extern SysTimePushDefaultTypeInternal _SysTimePush_default_instance_;
class TalentPush;
struct TalentPushDefaultTypeInternal;
extern TalentPushDefaultTypeInternal _TalentPush_default_instance_;
class UserAccountLoginRequest;
struct UserAccountLoginRequestDefaultTypeInternal;
extern UserAccountLoginRequestDefaultTypeInternal _UserAccountLoginRequest_default_instance_;
class UserAccountLoginResponse;
struct UserAccountLoginResponseDefaultTypeInternal;
extern UserAccountLoginResponseDefaultTypeInternal _UserAccountLoginResponse_default_instance_;
class VipActiveInfoPush;
struct VipActiveInfoPushDefaultTypeInternal;
extern VipActiveInfoPushDefaultTypeInternal _VipActiveInfoPush_default_instance_;
class VipInfoPush;
struct VipInfoPushDefaultTypeInternal;
extern VipInfoPushDefaultTypeInternal _VipInfoPush_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ChangeNameRequest* Arena::CreateMaybeMessage<::ChangeNameRequest>(Arena*);
template<> ::ChangeNameResponse* Arena::CreateMaybeMessage<::ChangeNameResponse>(Arena*);
template<> ::GuideDTO* Arena::CreateMaybeMessage<::GuideDTO>(Arena*);
template<> ::GuidePush* Arena::CreateMaybeMessage<::GuidePush>(Arena*);
template<> ::PlayeBattlePush* Arena::CreateMaybeMessage<::PlayeBattlePush>(Arena*);
template<> ::PlayerCount* Arena::CreateMaybeMessage<::PlayerCount>(Arena*);
template<> ::PlayerCountPush* Arena::CreateMaybeMessage<::PlayerCountPush>(Arena*);
template<> ::PlayerDTO* Arena::CreateMaybeMessage<::PlayerDTO>(Arena*);
template<> ::PlayerDataPush* Arena::CreateMaybeMessage<::PlayerDataPush>(Arena*);
template<> ::PlayerHeartBeatRequest* Arena::CreateMaybeMessage<::PlayerHeartBeatRequest>(Arena*);
template<> ::PlayerHeartBeatResponse* Arena::CreateMaybeMessage<::PlayerHeartBeatResponse>(Arena*);
template<> ::PlayerLevelUpPush* Arena::CreateMaybeMessage<::PlayerLevelUpPush>(Arena*);
template<> ::PlayerLoginRequest* Arena::CreateMaybeMessage<::PlayerLoginRequest>(Arena*);
template<> ::PlayerLoginResponse* Arena::CreateMaybeMessage<::PlayerLoginResponse>(Arena*);
template<> ::PlayerPropertyChangePush* Arena::CreateMaybeMessage<::PlayerPropertyChangePush>(Arena*);
template<> ::PlayerProtectPush* Arena::CreateMaybeMessage<::PlayerProtectPush>(Arena*);
template<> ::PlayerReconnectRequest* Arena::CreateMaybeMessage<::PlayerReconnectRequest>(Arena*);
template<> ::PlayerReconnectResponse* Arena::CreateMaybeMessage<::PlayerReconnectResponse>(Arena*);
template<> ::PlayerReloadRequest* Arena::CreateMaybeMessage<::PlayerReloadRequest>(Arena*);
template<> ::PlayerReloadResponse* Arena::CreateMaybeMessage<::PlayerReloadResponse>(Arena*);
template<> ::QueryLordInfoRequest* Arena::CreateMaybeMessage<::QueryLordInfoRequest>(Arena*);
template<> ::QueryLordInfoResponse* Arena::CreateMaybeMessage<::QueryLordInfoResponse>(Arena*);
template<> ::SetGuideRequest* Arena::CreateMaybeMessage<::SetGuideRequest>(Arena*);
template<> ::SetIconRequest* Arena::CreateMaybeMessage<::SetIconRequest>(Arena*);
template<> ::SetIconResponse* Arena::CreateMaybeMessage<::SetIconResponse>(Arena*);
template<> ::SetImageRequest* Arena::CreateMaybeMessage<::SetImageRequest>(Arena*);
template<> ::SetImageResponse* Arena::CreateMaybeMessage<::SetImageResponse>(Arena*);
template<> ::SetTalentRequest* Arena::CreateMaybeMessage<::SetTalentRequest>(Arena*);
template<> ::SetTalentResponse* Arena::CreateMaybeMessage<::SetTalentResponse>(Arena*);
template<> ::SysTimePush* Arena::CreateMaybeMessage<::SysTimePush>(Arena*);
template<> ::TalentPush* Arena::CreateMaybeMessage<::TalentPush>(Arena*);
template<> ::UserAccountLoginRequest* Arena::CreateMaybeMessage<::UserAccountLoginRequest>(Arena*);
template<> ::UserAccountLoginResponse* Arena::CreateMaybeMessage<::UserAccountLoginResponse>(Arena*);
template<> ::VipActiveInfoPush* Arena::CreateMaybeMessage<::VipActiveInfoPush>(Arena*);
template<> ::VipInfoPush* Arena::CreateMaybeMessage<::VipInfoPush>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum PlayerCommandId : int {
  USER_ACCOUNT_LOGIN = 100,
  PLAYER_LOGIN = 101,
  PLAYER_RECONNECT = 102,
  PLAYRE_HEARTBEAT = 103,
  PLAYRE_RELOAD = 104,
  PLAYER_TALENT_SET = 105,
  PLAYER_IMAGE_SET = 106,
  PLAYER_QUERY_PLAYER = 107,
  PLAYER_ICON_SET = 108,
  PLAYER_CHANGE_NAME = 109,
  PLAYER_SET_GUIDE = 110,
  PLAYER_JUMP_GUIDE = 111
};
bool PlayerCommandId_IsValid(int value);
constexpr PlayerCommandId PlayerCommandId_MIN = USER_ACCOUNT_LOGIN;
constexpr PlayerCommandId PlayerCommandId_MAX = PLAYER_JUMP_GUIDE;
constexpr int PlayerCommandId_ARRAYSIZE = PlayerCommandId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerCommandId_descriptor();
template<typename T>
inline const std::string& PlayerCommandId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerCommandId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerCommandId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerCommandId_descriptor(), enum_t_value);
}
inline bool PlayerCommandId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerCommandId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerCommandId>(
    PlayerCommandId_descriptor(), name, value);
}
enum ReconnectState : int {
  CONTINUE = 1,
  RELOAD = 2,
  RELOGIN = 3
};
bool ReconnectState_IsValid(int value);
constexpr ReconnectState ReconnectState_MIN = CONTINUE;
constexpr ReconnectState ReconnectState_MAX = RELOGIN;
constexpr int ReconnectState_ARRAYSIZE = ReconnectState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReconnectState_descriptor();
template<typename T>
inline const std::string& ReconnectState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReconnectState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReconnectState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReconnectState_descriptor(), enum_t_value);
}
inline bool ReconnectState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReconnectState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReconnectState>(
    ReconnectState_descriptor(), name, value);
}
enum PlayerPushId : int {
  PLAYRE_DATA_PUSH = 50101,
  PROPERTY_CHANGE_PUSH = 50102,
  PLAYER_LEVEL_UP_PUSH = 50103,
  PLAYER_PROTECT_PUSH = 50104,
  PLAYER_RELOGIN = 50110,
  PLAYER_COUNT_PUSH = 50120,
  PLAYER_BATTLE_PUSH = 50121,
  PLAYER_TALENT_PUSH = 50122,
  PLAYER_VIP_PUSH = 50123,
  PLAYER_VIP_ACTIVE_PUSH = 50124,
  PLAYER_SYS_TIME_PUSH = 50125,
  PLAYER_ONLINE_OTHER_DAY = 50126,
  PLAYER_GUIDE_PUSH = 50127
};
bool PlayerPushId_IsValid(int value);
constexpr PlayerPushId PlayerPushId_MIN = PLAYRE_DATA_PUSH;
constexpr PlayerPushId PlayerPushId_MAX = PLAYER_GUIDE_PUSH;
constexpr int PlayerPushId_ARRAYSIZE = PlayerPushId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerPushId_descriptor();
template<typename T>
inline const std::string& PlayerPushId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerPushId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerPushId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerPushId_descriptor(), enum_t_value);
}
inline bool PlayerPushId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerPushId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerPushId>(
    PlayerPushId_descriptor(), name, value);
}
// ===================================================================

class PlayerDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerDTO) */ {
 public:
  inline PlayerDTO() : PlayerDTO(nullptr) {}
  ~PlayerDTO() override;
  explicit PROTOBUF_CONSTEXPR PlayerDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerDTO(const PlayerDTO& from);
  PlayerDTO(PlayerDTO&& from) noexcept
    : PlayerDTO() {
    *this = ::std::move(from);
  }

  inline PlayerDTO& operator=(const PlayerDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDTO& operator=(PlayerDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDTO* internal_default_instance() {
    return reinterpret_cast<const PlayerDTO*>(
               &_PlayerDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerDTO& a, PlayerDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerDTO";
  }
  protected:
  explicit PlayerDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kNameFieldNumber = 2,
    kLanguageFieldNumber = 5,
    kIconFieldNumber = 8,
    kMapGridPositionFieldNumber = 6,
    kPlayerIdFieldNumber = 1,
    kLevelFieldNumber = 3,
    kHasChangedNameFieldNumber = 7,
  };
  // repeated .PropertyDTO properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::PropertyDTO* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >*
      mutable_properties();
  private:
  const ::PropertyDTO& _internal_properties(int index) const;
  ::PropertyDTO* _internal_add_properties();
  public:
  const ::PropertyDTO& properties(int index) const;
  ::PropertyDTO* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >&
      properties() const;

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string language = 5;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // required string icon = 8;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // required .PositionDTO mapGridPosition = 6;
  bool has_mapgridposition() const;
  private:
  bool _internal_has_mapgridposition() const;
  public:
  void clear_mapgridposition();
  const ::PositionDTO& mapgridposition() const;
  PROTOBUF_NODISCARD ::PositionDTO* release_mapgridposition();
  ::PositionDTO* mutable_mapgridposition();
  void set_allocated_mapgridposition(::PositionDTO* mapgridposition);
  private:
  const ::PositionDTO& _internal_mapgridposition() const;
  ::PositionDTO* _internal_mutable_mapgridposition();
  public:
  void unsafe_arena_set_allocated_mapgridposition(
      ::PositionDTO* mapgridposition);
  ::PositionDTO* unsafe_arena_release_mapgridposition();

  // required uint64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // required int32 level = 3;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // required bool hasChangedName = 7;
  bool has_haschangedname() const;
  private:
  bool _internal_has_haschangedname() const;
  public:
  void clear_haschangedname();
  bool haschangedname() const;
  void set_haschangedname(bool value);
  private:
  bool _internal_haschangedname() const;
  void _internal_set_haschangedname(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerDTO)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO > properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PositionDTO* mapgridposition_;
  uint64_t playerid_;
  int32_t level_;
  bool haschangedname_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GuideDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuideDTO) */ {
 public:
  inline GuideDTO() : GuideDTO(nullptr) {}
  ~GuideDTO() override;
  explicit PROTOBUF_CONSTEXPR GuideDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuideDTO(const GuideDTO& from);
  GuideDTO(GuideDTO&& from) noexcept
    : GuideDTO() {
    *this = ::std::move(from);
  }

  inline GuideDTO& operator=(const GuideDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideDTO& operator=(GuideDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideDTO* internal_default_instance() {
    return reinterpret_cast<const GuideDTO*>(
               &_GuideDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GuideDTO& a, GuideDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(GuideDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuideDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuideDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GuideDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuideDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuideDTO";
  }
  protected:
  explicit GuideDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kJumpFieldNumber = 3,
  };
  // required int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required bool jump = 3;
  bool has_jump() const;
  private:
  bool _internal_has_jump() const;
  public:
  void clear_jump();
  bool jump() const;
  void set_jump(bool value);
  private:
  bool _internal_jump() const;
  void _internal_set_jump(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GuideDTO)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t id_;
  bool jump_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class UserAccountLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserAccountLoginRequest) */ {
 public:
  inline UserAccountLoginRequest() : UserAccountLoginRequest(nullptr) {}
  ~UserAccountLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR UserAccountLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAccountLoginRequest(const UserAccountLoginRequest& from);
  UserAccountLoginRequest(UserAccountLoginRequest&& from) noexcept
    : UserAccountLoginRequest() {
    *this = ::std::move(from);
  }

  inline UserAccountLoginRequest& operator=(const UserAccountLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAccountLoginRequest& operator=(UserAccountLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAccountLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAccountLoginRequest* internal_default_instance() {
    return reinterpret_cast<const UserAccountLoginRequest*>(
               &_UserAccountLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserAccountLoginRequest& a, UserAccountLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAccountLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAccountLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAccountLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAccountLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAccountLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserAccountLoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAccountLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserAccountLoginRequest";
  }
  protected:
  explicit UserAccountLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 1,
    kPuidFieldNumber = 2,
  };
  // required string platform = 1;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // required string puid = 2;
  bool has_puid() const;
  private:
  bool _internal_has_puid() const;
  public:
  void clear_puid();
  const std::string& puid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_puid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_puid();
  PROTOBUF_NODISCARD std::string* release_puid();
  void set_allocated_puid(std::string* puid);
  private:
  const std::string& _internal_puid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_puid(const std::string& value);
  std::string* _internal_mutable_puid();
  public:

  // @@protoc_insertion_point(class_scope:UserAccountLoginRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr puid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class UserAccountLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserAccountLoginResponse) */ {
 public:
  inline UserAccountLoginResponse() : UserAccountLoginResponse(nullptr) {}
  ~UserAccountLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR UserAccountLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAccountLoginResponse(const UserAccountLoginResponse& from);
  UserAccountLoginResponse(UserAccountLoginResponse&& from) noexcept
    : UserAccountLoginResponse() {
    *this = ::std::move(from);
  }

  inline UserAccountLoginResponse& operator=(const UserAccountLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAccountLoginResponse& operator=(UserAccountLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAccountLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAccountLoginResponse* internal_default_instance() {
    return reinterpret_cast<const UserAccountLoginResponse*>(
               &_UserAccountLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserAccountLoginResponse& a, UserAccountLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAccountLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAccountLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAccountLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAccountLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAccountLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserAccountLoginResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAccountLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserAccountLoginResponse";
  }
  protected:
  explicit UserAccountLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // required uint64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserAccountLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t playerid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerLoginRequest) */ {
 public:
  inline PlayerLoginRequest() : PlayerLoginRequest(nullptr) {}
  ~PlayerLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerLoginRequest(const PlayerLoginRequest& from);
  PlayerLoginRequest(PlayerLoginRequest&& from) noexcept
    : PlayerLoginRequest() {
    *this = ::std::move(from);
  }

  inline PlayerLoginRequest& operator=(const PlayerLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLoginRequest& operator=(PlayerLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerLoginRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerLoginRequest*>(
               &_PlayerLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerLoginRequest& a, PlayerLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerLoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerLoginRequest";
  }
  protected:
  explicit PlayerLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // required uint64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t playerid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerLoginResponse) */ {
 public:
  inline PlayerLoginResponse() : PlayerLoginResponse(nullptr) {}
  ~PlayerLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerLoginResponse(const PlayerLoginResponse& from);
  PlayerLoginResponse(PlayerLoginResponse&& from) noexcept
    : PlayerLoginResponse() {
    *this = ::std::move(from);
  }

  inline PlayerLoginResponse& operator=(const PlayerLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLoginResponse& operator=(PlayerLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerLoginResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerLoginResponse*>(
               &_PlayerLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerLoginResponse& a, PlayerLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerLoginResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerLoginResponse";
  }
  protected:
  explicit PlayerLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kSystimeFieldNumber = 2,
    kTimeZoneOffsetFieldNumber = 3,
  };
  // required uint64 sessionId = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // required int64 systime = 2;
  bool has_systime() const;
  private:
  bool _internal_has_systime() const;
  public:
  void clear_systime();
  int64_t systime() const;
  void set_systime(int64_t value);
  private:
  int64_t _internal_systime() const;
  void _internal_set_systime(int64_t value);
  public:

  // required int32 timeZoneOffset = 3;
  bool has_timezoneoffset() const;
  private:
  bool _internal_has_timezoneoffset() const;
  public:
  void clear_timezoneoffset();
  int32_t timezoneoffset() const;
  void set_timezoneoffset(int32_t value);
  private:
  int32_t _internal_timezoneoffset() const;
  void _internal_set_timezoneoffset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerLoginResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t sessionid_;
  int64_t systime_;
  int32_t timezoneoffset_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerReconnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerReconnectRequest) */ {
 public:
  inline PlayerReconnectRequest() : PlayerReconnectRequest(nullptr) {}
  ~PlayerReconnectRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerReconnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReconnectRequest(const PlayerReconnectRequest& from);
  PlayerReconnectRequest(PlayerReconnectRequest&& from) noexcept
    : PlayerReconnectRequest() {
    *this = ::std::move(from);
  }

  inline PlayerReconnectRequest& operator=(const PlayerReconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReconnectRequest& operator=(PlayerReconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReconnectRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerReconnectRequest*>(
               &_PlayerReconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlayerReconnectRequest& a, PlayerReconnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReconnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReconnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReconnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReconnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReconnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReconnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReconnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerReconnectRequest";
  }
  protected:
  explicit PlayerReconnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kLastPushIdFieldNumber = 2,
  };
  // required uint64 sessionId = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // required int32 lastPushId = 2;
  bool has_lastpushid() const;
  private:
  bool _internal_has_lastpushid() const;
  public:
  void clear_lastpushid();
  int32_t lastpushid() const;
  void set_lastpushid(int32_t value);
  private:
  int32_t _internal_lastpushid() const;
  void _internal_set_lastpushid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerReconnectRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t sessionid_;
  int32_t lastpushid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerReconnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerReconnectResponse) */ {
 public:
  inline PlayerReconnectResponse() : PlayerReconnectResponse(nullptr) {}
  ~PlayerReconnectResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerReconnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReconnectResponse(const PlayerReconnectResponse& from);
  PlayerReconnectResponse(PlayerReconnectResponse&& from) noexcept
    : PlayerReconnectResponse() {
    *this = ::std::move(from);
  }

  inline PlayerReconnectResponse& operator=(const PlayerReconnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReconnectResponse& operator=(PlayerReconnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReconnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReconnectResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerReconnectResponse*>(
               &_PlayerReconnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerReconnectResponse& a, PlayerReconnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReconnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReconnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReconnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReconnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReconnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReconnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReconnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerReconnectResponse";
  }
  protected:
  explicit PlayerReconnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // optional .ReconnectState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::ReconnectState state() const;
  void set_state(::ReconnectState value);
  private:
  ::ReconnectState _internal_state() const;
  void _internal_set_state(::ReconnectState value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerReconnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerReloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PlayerReloadRequest) */ {
 public:
  inline PlayerReloadRequest() : PlayerReloadRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PlayerReloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReloadRequest(const PlayerReloadRequest& from);
  PlayerReloadRequest(PlayerReloadRequest&& from) noexcept
    : PlayerReloadRequest() {
    *this = ::std::move(from);
  }

  inline PlayerReloadRequest& operator=(const PlayerReloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReloadRequest& operator=(PlayerReloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReloadRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerReloadRequest*>(
               &_PlayerReloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerReloadRequest& a, PlayerReloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PlayerReloadRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PlayerReloadRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerReloadRequest";
  }
  protected:
  explicit PlayerReloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PlayerReloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerReloadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerReloadResponse) */ {
 public:
  inline PlayerReloadResponse() : PlayerReloadResponse(nullptr) {}
  ~PlayerReloadResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerReloadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReloadResponse(const PlayerReloadResponse& from);
  PlayerReloadResponse(PlayerReloadResponse&& from) noexcept
    : PlayerReloadResponse() {
    *this = ::std::move(from);
  }

  inline PlayerReloadResponse& operator=(const PlayerReloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReloadResponse& operator=(PlayerReloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReloadResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerReloadResponse*>(
               &_PlayerReloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerReloadResponse& a, PlayerReloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReloadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReloadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReloadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReloadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReloadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerReloadResponse";
  }
  protected:
  explicit PlayerReloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystimeFieldNumber = 1,
    kTimeZoneOffsetFieldNumber = 2,
  };
  // required int64 systime = 1;
  bool has_systime() const;
  private:
  bool _internal_has_systime() const;
  public:
  void clear_systime();
  int64_t systime() const;
  void set_systime(int64_t value);
  private:
  int64_t _internal_systime() const;
  void _internal_set_systime(int64_t value);
  public:

  // required int32 timeZoneOffset = 2;
  bool has_timezoneoffset() const;
  private:
  bool _internal_has_timezoneoffset() const;
  public:
  void clear_timezoneoffset();
  int32_t timezoneoffset() const;
  void set_timezoneoffset(int32_t value);
  private:
  int32_t _internal_timezoneoffset() const;
  void _internal_set_timezoneoffset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerReloadResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t systime_;
  int32_t timezoneoffset_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerHeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PlayerHeartBeatRequest) */ {
 public:
  inline PlayerHeartBeatRequest() : PlayerHeartBeatRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PlayerHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerHeartBeatRequest(const PlayerHeartBeatRequest& from);
  PlayerHeartBeatRequest(PlayerHeartBeatRequest&& from) noexcept
    : PlayerHeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline PlayerHeartBeatRequest& operator=(const PlayerHeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerHeartBeatRequest& operator=(PlayerHeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerHeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerHeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerHeartBeatRequest*>(
               &_PlayerHeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlayerHeartBeatRequest& a, PlayerHeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerHeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerHeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerHeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerHeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PlayerHeartBeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PlayerHeartBeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerHeartBeatRequest";
  }
  protected:
  explicit PlayerHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PlayerHeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerHeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerHeartBeatResponse) */ {
 public:
  inline PlayerHeartBeatResponse() : PlayerHeartBeatResponse(nullptr) {}
  ~PlayerHeartBeatResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerHeartBeatResponse(const PlayerHeartBeatResponse& from);
  PlayerHeartBeatResponse(PlayerHeartBeatResponse&& from) noexcept
    : PlayerHeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline PlayerHeartBeatResponse& operator=(const PlayerHeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerHeartBeatResponse& operator=(PlayerHeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerHeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerHeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerHeartBeatResponse*>(
               &_PlayerHeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlayerHeartBeatResponse& a, PlayerHeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerHeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerHeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerHeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerHeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerHeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerHeartBeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerHeartBeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerHeartBeatResponse";
  }
  protected:
  explicit PlayerHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystimeFieldNumber = 1,
  };
  // required int64 systime = 1;
  bool has_systime() const;
  private:
  bool _internal_has_systime() const;
  public:
  void clear_systime();
  int64_t systime() const;
  void set_systime(int64_t value);
  private:
  int64_t _internal_systime() const;
  void _internal_set_systime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerHeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t systime_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetTalentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetTalentRequest) */ {
 public:
  inline SetTalentRequest() : SetTalentRequest(nullptr) {}
  ~SetTalentRequest() override;
  explicit PROTOBUF_CONSTEXPR SetTalentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTalentRequest(const SetTalentRequest& from);
  SetTalentRequest(SetTalentRequest&& from) noexcept
    : SetTalentRequest() {
    *this = ::std::move(from);
  }

  inline SetTalentRequest& operator=(const SetTalentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTalentRequest& operator=(SetTalentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTalentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTalentRequest* internal_default_instance() {
    return reinterpret_cast<const SetTalentRequest*>(
               &_SetTalentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetTalentRequest& a, SetTalentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTalentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTalentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTalentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTalentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTalentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetTalentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTalentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetTalentRequest";
  }
  protected:
  explicit SetTalentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kTalentIdFieldNumber = 2,
  };
  // required int32 level = 1;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // required int32 talentId = 2;
  bool has_talentid() const;
  private:
  bool _internal_has_talentid() const;
  public:
  void clear_talentid();
  int32_t talentid() const;
  void set_talentid(int32_t value);
  private:
  int32_t _internal_talentid() const;
  void _internal_set_talentid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetTalentRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t level_;
  int32_t talentid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetTalentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetTalentResponse) */ {
 public:
  inline SetTalentResponse() : SetTalentResponse(nullptr) {}
  ~SetTalentResponse() override;
  explicit PROTOBUF_CONSTEXPR SetTalentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTalentResponse(const SetTalentResponse& from);
  SetTalentResponse(SetTalentResponse&& from) noexcept
    : SetTalentResponse() {
    *this = ::std::move(from);
  }

  inline SetTalentResponse& operator=(const SetTalentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTalentResponse& operator=(SetTalentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTalentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTalentResponse* internal_default_instance() {
    return reinterpret_cast<const SetTalentResponse*>(
               &_SetTalentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetTalentResponse& a, SetTalentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTalentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTalentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTalentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTalentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTalentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetTalentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTalentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetTalentResponse";
  }
  protected:
  explicit SetTalentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kTalentIdFieldNumber = 2,
  };
  // required int32 level = 1;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // required int32 talentId = 2;
  bool has_talentid() const;
  private:
  bool _internal_has_talentid() const;
  public:
  void clear_talentid();
  int32_t talentid() const;
  void set_talentid(int32_t value);
  private:
  int32_t _internal_talentid() const;
  void _internal_set_talentid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetTalentResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t level_;
  int32_t talentid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetImageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetImageRequest) */ {
 public:
  inline SetImageRequest() : SetImageRequest(nullptr) {}
  ~SetImageRequest() override;
  explicit PROTOBUF_CONSTEXPR SetImageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetImageRequest(const SetImageRequest& from);
  SetImageRequest(SetImageRequest&& from) noexcept
    : SetImageRequest() {
    *this = ::std::move(from);
  }

  inline SetImageRequest& operator=(const SetImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetImageRequest& operator=(SetImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetImageRequest* internal_default_instance() {
    return reinterpret_cast<const SetImageRequest*>(
               &_SetImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetImageRequest& a, SetImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetImageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetImageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetImageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetImageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetImageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetImageRequest";
  }
  protected:
  explicit SetImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
  };
  // required int32 image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  int32_t image() const;
  void set_image(int32_t value);
  private:
  int32_t _internal_image() const;
  void _internal_set_image(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t image_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetImageResponse) */ {
 public:
  inline SetImageResponse() : SetImageResponse(nullptr) {}
  ~SetImageResponse() override;
  explicit PROTOBUF_CONSTEXPR SetImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetImageResponse(const SetImageResponse& from);
  SetImageResponse(SetImageResponse&& from) noexcept
    : SetImageResponse() {
    *this = ::std::move(from);
  }

  inline SetImageResponse& operator=(const SetImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetImageResponse& operator=(SetImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetImageResponse* internal_default_instance() {
    return reinterpret_cast<const SetImageResponse*>(
               &_SetImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetImageResponse& a, SetImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetImageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetImageResponse";
  }
  protected:
  explicit SetImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
  };
  // optional int32 image = 2;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  int32_t image() const;
  void set_image(int32_t value);
  private:
  int32_t _internal_image() const;
  void _internal_set_image(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t image_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class QueryLordInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryLordInfoRequest) */ {
 public:
  inline QueryLordInfoRequest() : QueryLordInfoRequest(nullptr) {}
  ~QueryLordInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryLordInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLordInfoRequest(const QueryLordInfoRequest& from);
  QueryLordInfoRequest(QueryLordInfoRequest&& from) noexcept
    : QueryLordInfoRequest() {
    *this = ::std::move(from);
  }

  inline QueryLordInfoRequest& operator=(const QueryLordInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLordInfoRequest& operator=(QueryLordInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLordInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLordInfoRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLordInfoRequest*>(
               &_QueryLordInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(QueryLordInfoRequest& a, QueryLordInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLordInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLordInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLordInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLordInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLordInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLordInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLordInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryLordInfoRequest";
  }
  protected:
  explicit QueryLordInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  int64_t playerid() const;
  void set_playerid(int64_t value);
  private:
  int64_t _internal_playerid() const;
  void _internal_set_playerid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:QueryLordInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int64_t playerid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class QueryLordInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryLordInfoResponse) */ {
 public:
  inline QueryLordInfoResponse() : QueryLordInfoResponse(nullptr) {}
  ~QueryLordInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryLordInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLordInfoResponse(const QueryLordInfoResponse& from);
  QueryLordInfoResponse(QueryLordInfoResponse&& from) noexcept
    : QueryLordInfoResponse() {
    *this = ::std::move(from);
  }

  inline QueryLordInfoResponse& operator=(const QueryLordInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLordInfoResponse& operator=(QueryLordInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLordInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLordInfoResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLordInfoResponse*>(
               &_QueryLordInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(QueryLordInfoResponse& a, QueryLordInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLordInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLordInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLordInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLordInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLordInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLordInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLordInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryLordInfoResponse";
  }
  protected:
  explicit QueryLordInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipmentlistFieldNumber = 9,
    kNicknameFieldNumber = 2,
    kAlliancenameFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
    kAllianceidFieldNumber = 3,
    kExpFieldNumber = 5,
    kLevelFieldNumber = 6,
    kIsfriendFieldNumber = 7,
    kImageFieldNumber = 8,
  };
  // repeated .EquipmentDTO equipmentlist = 9;
  int equipmentlist_size() const;
  private:
  int _internal_equipmentlist_size() const;
  public:
  void clear_equipmentlist();
  ::EquipmentDTO* mutable_equipmentlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EquipmentDTO >*
      mutable_equipmentlist();
  private:
  const ::EquipmentDTO& _internal_equipmentlist(int index) const;
  ::EquipmentDTO* _internal_add_equipmentlist();
  public:
  const ::EquipmentDTO& equipmentlist(int index) const;
  ::EquipmentDTO* add_equipmentlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EquipmentDTO >&
      equipmentlist() const;

  // optional string nickname = 2;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // optional string alliancename = 4;
  bool has_alliancename() const;
  private:
  bool _internal_has_alliancename() const;
  public:
  void clear_alliancename();
  const std::string& alliancename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alliancename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alliancename();
  PROTOBUF_NODISCARD std::string* release_alliancename();
  void set_allocated_alliancename(std::string* alliancename);
  private:
  const std::string& _internal_alliancename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alliancename(const std::string& value);
  std::string* _internal_mutable_alliancename();
  public:

  // optional int64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  int64_t playerid() const;
  void set_playerid(int64_t value);
  private:
  int64_t _internal_playerid() const;
  void _internal_set_playerid(int64_t value);
  public:

  // optional int32 allianceid = 3;
  bool has_allianceid() const;
  private:
  bool _internal_has_allianceid() const;
  public:
  void clear_allianceid();
  int32_t allianceid() const;
  void set_allianceid(int32_t value);
  private:
  int32_t _internal_allianceid() const;
  void _internal_set_allianceid(int32_t value);
  public:

  // optional int32 exp = 5;
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;
  public:
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // optional int32 level = 6;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // optional bool isfriend = 7;
  bool has_isfriend() const;
  private:
  bool _internal_has_isfriend() const;
  public:
  void clear_isfriend();
  bool isfriend() const;
  void set_isfriend(bool value);
  private:
  bool _internal_isfriend() const;
  void _internal_set_isfriend(bool value);
  public:

  // optional int32 image = 8;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  int32_t image() const;
  void set_image(int32_t value);
  private:
  int32_t _internal_image() const;
  void _internal_set_image(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QueryLordInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EquipmentDTO > equipmentlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alliancename_;
  int64_t playerid_;
  int32_t allianceid_;
  int32_t exp_;
  int32_t level_;
  bool isfriend_;
  int32_t image_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetIconRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetIconRequest) */ {
 public:
  inline SetIconRequest() : SetIconRequest(nullptr) {}
  ~SetIconRequest() override;
  explicit PROTOBUF_CONSTEXPR SetIconRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetIconRequest(const SetIconRequest& from);
  SetIconRequest(SetIconRequest&& from) noexcept
    : SetIconRequest() {
    *this = ::std::move(from);
  }

  inline SetIconRequest& operator=(const SetIconRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetIconRequest& operator=(SetIconRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetIconRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetIconRequest* internal_default_instance() {
    return reinterpret_cast<const SetIconRequest*>(
               &_SetIconRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetIconRequest& a, SetIconRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetIconRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetIconRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetIconRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetIconRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetIconRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetIconRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetIconRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetIconRequest";
  }
  protected:
  explicit SetIconRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconIDFieldNumber = 1,
    kOperFieldNumber = 2,
  };
  // required string iconID = 1;
  bool has_iconid() const;
  private:
  bool _internal_has_iconid() const;
  public:
  void clear_iconid();
  const std::string& iconid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iconid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iconid();
  PROTOBUF_NODISCARD std::string* release_iconid();
  void set_allocated_iconid(std::string* iconid);
  private:
  const std::string& _internal_iconid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iconid(const std::string& value);
  std::string* _internal_mutable_iconid();
  public:

  // required int32 oper = 2;
  bool has_oper() const;
  private:
  bool _internal_has_oper() const;
  public:
  void clear_oper();
  int32_t oper() const;
  void set_oper(int32_t value);
  private:
  int32_t _internal_oper() const;
  void _internal_set_oper(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetIconRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iconid_;
  int32_t oper_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetIconResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetIconResponse) */ {
 public:
  inline SetIconResponse() : SetIconResponse(nullptr) {}
  ~SetIconResponse() override;
  explicit PROTOBUF_CONSTEXPR SetIconResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetIconResponse(const SetIconResponse& from);
  SetIconResponse(SetIconResponse&& from) noexcept
    : SetIconResponse() {
    *this = ::std::move(from);
  }

  inline SetIconResponse& operator=(const SetIconResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetIconResponse& operator=(SetIconResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetIconResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetIconResponse* internal_default_instance() {
    return reinterpret_cast<const SetIconResponse*>(
               &_SetIconResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetIconResponse& a, SetIconResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetIconResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetIconResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetIconResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetIconResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetIconResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetIconResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetIconResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetIconResponse";
  }
  protected:
  explicit SetIconResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconIDFieldNumber = 2,
  };
  // optional string iconID = 2;
  bool has_iconid() const;
  private:
  bool _internal_has_iconid() const;
  public:
  void clear_iconid();
  const std::string& iconid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iconid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iconid();
  PROTOBUF_NODISCARD std::string* release_iconid();
  void set_allocated_iconid(std::string* iconid);
  private:
  const std::string& _internal_iconid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iconid(const std::string& value);
  std::string* _internal_mutable_iconid();
  public:

  // @@protoc_insertion_point(class_scope:SetIconResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iconid_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class ChangeNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChangeNameRequest) */ {
 public:
  inline ChangeNameRequest() : ChangeNameRequest(nullptr) {}
  ~ChangeNameRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeNameRequest(const ChangeNameRequest& from);
  ChangeNameRequest(ChangeNameRequest&& from) noexcept
    : ChangeNameRequest() {
    *this = ::std::move(from);
  }

  inline ChangeNameRequest& operator=(const ChangeNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNameRequest& operator=(ChangeNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNameRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeNameRequest*>(
               &_ChangeNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ChangeNameRequest& a, ChangeNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeNameRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeNameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChangeNameRequest";
  }
  protected:
  explicit ChangeNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kUseItemFieldNumber = 2,
  };
  // required string nickname = 1;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // required bool useItem = 2;
  bool has_useitem() const;
  private:
  bool _internal_has_useitem() const;
  public:
  void clear_useitem();
  bool useitem() const;
  void set_useitem(bool value);
  private:
  bool _internal_useitem() const;
  void _internal_set_useitem(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ChangeNameRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  bool useitem_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class ChangeNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChangeNameResponse) */ {
 public:
  inline ChangeNameResponse() : ChangeNameResponse(nullptr) {}
  ~ChangeNameResponse() override;
  explicit PROTOBUF_CONSTEXPR ChangeNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeNameResponse(const ChangeNameResponse& from);
  ChangeNameResponse(ChangeNameResponse&& from) noexcept
    : ChangeNameResponse() {
    *this = ::std::move(from);
  }

  inline ChangeNameResponse& operator=(const ChangeNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNameResponse& operator=(ChangeNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNameResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeNameResponse*>(
               &_ChangeNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ChangeNameResponse& a, ChangeNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeNameResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeNameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChangeNameResponse";
  }
  protected:
  explicit ChangeNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardFieldNumber = 2,
    kIsAvailableFieldNumber = 1,
  };
  // optional .PropertyDTO reward = 2;
  bool has_reward() const;
  private:
  bool _internal_has_reward() const;
  public:
  void clear_reward();
  const ::PropertyDTO& reward() const;
  PROTOBUF_NODISCARD ::PropertyDTO* release_reward();
  ::PropertyDTO* mutable_reward();
  void set_allocated_reward(::PropertyDTO* reward);
  private:
  const ::PropertyDTO& _internal_reward() const;
  ::PropertyDTO* _internal_mutable_reward();
  public:
  void unsafe_arena_set_allocated_reward(
      ::PropertyDTO* reward);
  ::PropertyDTO* unsafe_arena_release_reward();

  // required bool isAvailable = 1;
  bool has_isavailable() const;
  private:
  bool _internal_has_isavailable() const;
  public:
  void clear_isavailable();
  bool isavailable() const;
  void set_isavailable(bool value);
  private:
  bool _internal_isavailable() const;
  void _internal_set_isavailable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ChangeNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PropertyDTO* reward_;
  bool isavailable_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetGuideRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetGuideRequest) */ {
 public:
  inline SetGuideRequest() : SetGuideRequest(nullptr) {}
  ~SetGuideRequest() override;
  explicit PROTOBUF_CONSTEXPR SetGuideRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetGuideRequest(const SetGuideRequest& from);
  SetGuideRequest(SetGuideRequest&& from) noexcept
    : SetGuideRequest() {
    *this = ::std::move(from);
  }

  inline SetGuideRequest& operator=(const SetGuideRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetGuideRequest& operator=(SetGuideRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetGuideRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetGuideRequest* internal_default_instance() {
    return reinterpret_cast<const SetGuideRequest*>(
               &_SetGuideRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetGuideRequest& a, SetGuideRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetGuideRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetGuideRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetGuideRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetGuideRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetGuideRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetGuideRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetGuideRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetGuideRequest";
  }
  protected:
  explicit SetGuideRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetGuideRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t id_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerDataPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerDataPush) */ {
 public:
  inline PlayerDataPush() : PlayerDataPush(nullptr) {}
  ~PlayerDataPush() override;
  explicit PROTOBUF_CONSTEXPR PlayerDataPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerDataPush(const PlayerDataPush& from);
  PlayerDataPush(PlayerDataPush&& from) noexcept
    : PlayerDataPush() {
    *this = ::std::move(from);
  }

  inline PlayerDataPush& operator=(const PlayerDataPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDataPush& operator=(PlayerDataPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDataPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDataPush* internal_default_instance() {
    return reinterpret_cast<const PlayerDataPush*>(
               &_PlayerDataPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerDataPush& a, PlayerDataPush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDataPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDataPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDataPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDataPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerDataPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerDataPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerDataPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerDataPush";
  }
  protected:
  explicit PlayerDataPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // required .PlayerDTO player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::PlayerDTO& player() const;
  PROTOBUF_NODISCARD ::PlayerDTO* release_player();
  ::PlayerDTO* mutable_player();
  void set_allocated_player(::PlayerDTO* player);
  private:
  const ::PlayerDTO& _internal_player() const;
  ::PlayerDTO* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::PlayerDTO* player);
  ::PlayerDTO* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:PlayerDataPush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PlayerDTO* player_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerPropertyChangePush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerPropertyChangePush) */ {
 public:
  inline PlayerPropertyChangePush() : PlayerPropertyChangePush(nullptr) {}
  ~PlayerPropertyChangePush() override;
  explicit PROTOBUF_CONSTEXPR PlayerPropertyChangePush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerPropertyChangePush(const PlayerPropertyChangePush& from);
  PlayerPropertyChangePush(PlayerPropertyChangePush&& from) noexcept
    : PlayerPropertyChangePush() {
    *this = ::std::move(from);
  }

  inline PlayerPropertyChangePush& operator=(const PlayerPropertyChangePush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPropertyChangePush& operator=(PlayerPropertyChangePush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerPropertyChangePush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerPropertyChangePush* internal_default_instance() {
    return reinterpret_cast<const PlayerPropertyChangePush*>(
               &_PlayerPropertyChangePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayerPropertyChangePush& a, PlayerPropertyChangePush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPropertyChangePush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPropertyChangePush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerPropertyChangePush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerPropertyChangePush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerPropertyChangePush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerPropertyChangePush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerPropertyChangePush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerPropertyChangePush";
  }
  protected:
  explicit PlayerPropertyChangePush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
  };
  // repeated .PropertyDTO properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::PropertyDTO* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >*
      mutable_properties();
  private:
  const ::PropertyDTO& _internal_properties(int index) const;
  ::PropertyDTO* _internal_add_properties();
  public:
  const ::PropertyDTO& properties(int index) const;
  ::PropertyDTO* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >&
      properties() const;

  // @@protoc_insertion_point(class_scope:PlayerPropertyChangePush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO > properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerLevelUpPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerLevelUpPush) */ {
 public:
  inline PlayerLevelUpPush() : PlayerLevelUpPush(nullptr) {}
  ~PlayerLevelUpPush() override;
  explicit PROTOBUF_CONSTEXPR PlayerLevelUpPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerLevelUpPush(const PlayerLevelUpPush& from);
  PlayerLevelUpPush(PlayerLevelUpPush&& from) noexcept
    : PlayerLevelUpPush() {
    *this = ::std::move(from);
  }

  inline PlayerLevelUpPush& operator=(const PlayerLevelUpPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLevelUpPush& operator=(PlayerLevelUpPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLevelUpPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerLevelUpPush* internal_default_instance() {
    return reinterpret_cast<const PlayerLevelUpPush*>(
               &_PlayerLevelUpPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayerLevelUpPush& a, PlayerLevelUpPush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLevelUpPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLevelUpPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLevelUpPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerLevelUpPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerLevelUpPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerLevelUpPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLevelUpPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerLevelUpPush";
  }
  protected:
  explicit PlayerLevelUpPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // required int32 level = 1;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerLevelUpPush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t level_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerProtectPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerProtectPush) */ {
 public:
  inline PlayerProtectPush() : PlayerProtectPush(nullptr) {}
  ~PlayerProtectPush() override;
  explicit PROTOBUF_CONSTEXPR PlayerProtectPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerProtectPush(const PlayerProtectPush& from);
  PlayerProtectPush(PlayerProtectPush&& from) noexcept
    : PlayerProtectPush() {
    *this = ::std::move(from);
  }

  inline PlayerProtectPush& operator=(const PlayerProtectPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerProtectPush& operator=(PlayerProtectPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerProtectPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerProtectPush* internal_default_instance() {
    return reinterpret_cast<const PlayerProtectPush*>(
               &_PlayerProtectPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PlayerProtectPush& a, PlayerProtectPush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerProtectPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerProtectPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerProtectPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerProtectPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerProtectPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerProtectPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerProtectPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerProtectPush";
  }
  protected:
  explicit PlayerProtectPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBornProtectEndTimeFieldNumber = 1,
    kAtkProtectEndTimeFieldNumber = 2,
    kSpyProtectEndTimeFieldNumber = 3,
  };
  // required int32 bornProtectEndTime = 1;
  bool has_bornprotectendtime() const;
  private:
  bool _internal_has_bornprotectendtime() const;
  public:
  void clear_bornprotectendtime();
  int32_t bornprotectendtime() const;
  void set_bornprotectendtime(int32_t value);
  private:
  int32_t _internal_bornprotectendtime() const;
  void _internal_set_bornprotectendtime(int32_t value);
  public:

  // required int32 atkProtectEndTime = 2;
  bool has_atkprotectendtime() const;
  private:
  bool _internal_has_atkprotectendtime() const;
  public:
  void clear_atkprotectendtime();
  int32_t atkprotectendtime() const;
  void set_atkprotectendtime(int32_t value);
  private:
  int32_t _internal_atkprotectendtime() const;
  void _internal_set_atkprotectendtime(int32_t value);
  public:

  // required int32 spyProtectEndTime = 3;
  bool has_spyprotectendtime() const;
  private:
  bool _internal_has_spyprotectendtime() const;
  public:
  void clear_spyprotectendtime();
  int32_t spyprotectendtime() const;
  void set_spyprotectendtime(int32_t value);
  private:
  int32_t _internal_spyprotectendtime() const;
  void _internal_set_spyprotectendtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerProtectPush)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t bornprotectendtime_;
  int32_t atkprotectendtime_;
  int32_t spyprotectendtime_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerCount) */ {
 public:
  inline PlayerCount() : PlayerCount(nullptr) {}
  ~PlayerCount() override;
  explicit PROTOBUF_CONSTEXPR PlayerCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerCount(const PlayerCount& from);
  PlayerCount(PlayerCount&& from) noexcept
    : PlayerCount() {
    *this = ::std::move(from);
  }

  inline PlayerCount& operator=(const PlayerCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCount& operator=(PlayerCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerCount* internal_default_instance() {
    return reinterpret_cast<const PlayerCount*>(
               &_PlayerCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PlayerCount& a, PlayerCount& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerCount";
  }
  protected:
  explicit PlayerCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPointFieldNumber = 2,
    kDefCountFieldNumber = 3,
    kAddCountFieldNumber = 4,
  };
  // required int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // required int32 point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  int32_t point() const;
  void set_point(int32_t value);
  private:
  int32_t _internal_point() const;
  void _internal_set_point(int32_t value);
  public:

  // required int32 defCount = 3;
  bool has_defcount() const;
  private:
  bool _internal_has_defcount() const;
  public:
  void clear_defcount();
  int32_t defcount() const;
  void set_defcount(int32_t value);
  private:
  int32_t _internal_defcount() const;
  void _internal_set_defcount(int32_t value);
  public:

  // optional int32 addCount = 4;
  bool has_addcount() const;
  private:
  bool _internal_has_addcount() const;
  public:
  void clear_addcount();
  int32_t addcount() const;
  void set_addcount(int32_t value);
  private:
  int32_t _internal_addcount() const;
  void _internal_set_addcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerCount)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t type_;
  int32_t point_;
  int32_t defcount_;
  int32_t addcount_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayerCountPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerCountPush) */ {
 public:
  inline PlayerCountPush() : PlayerCountPush(nullptr) {}
  ~PlayerCountPush() override;
  explicit PROTOBUF_CONSTEXPR PlayerCountPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerCountPush(const PlayerCountPush& from);
  PlayerCountPush(PlayerCountPush&& from) noexcept
    : PlayerCountPush() {
    *this = ::std::move(from);
  }

  inline PlayerCountPush& operator=(const PlayerCountPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCountPush& operator=(PlayerCountPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerCountPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerCountPush* internal_default_instance() {
    return reinterpret_cast<const PlayerCountPush*>(
               &_PlayerCountPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PlayerCountPush& a, PlayerCountPush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCountPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerCountPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerCountPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerCountPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerCountPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerCountPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCountPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerCountPush";
  }
  protected:
  explicit PlayerCountPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountsFieldNumber = 1,
  };
  // repeated .PlayerCount counts = 1;
  int counts_size() const;
  private:
  int _internal_counts_size() const;
  public:
  void clear_counts();
  ::PlayerCount* mutable_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerCount >*
      mutable_counts();
  private:
  const ::PlayerCount& _internal_counts(int index) const;
  ::PlayerCount* _internal_add_counts();
  public:
  const ::PlayerCount& counts(int index) const;
  ::PlayerCount* add_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerCount >&
      counts() const;

  // @@protoc_insertion_point(class_scope:PlayerCountPush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerCount > counts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class PlayeBattlePush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayeBattlePush) */ {
 public:
  inline PlayeBattlePush() : PlayeBattlePush(nullptr) {}
  ~PlayeBattlePush() override;
  explicit PROTOBUF_CONSTEXPR PlayeBattlePush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayeBattlePush(const PlayeBattlePush& from);
  PlayeBattlePush(PlayeBattlePush&& from) noexcept
    : PlayeBattlePush() {
    *this = ::std::move(from);
  }

  inline PlayeBattlePush& operator=(const PlayeBattlePush& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayeBattlePush& operator=(PlayeBattlePush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayeBattlePush& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayeBattlePush* internal_default_instance() {
    return reinterpret_cast<const PlayeBattlePush*>(
               &_PlayeBattlePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PlayeBattlePush& a, PlayeBattlePush& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayeBattlePush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayeBattlePush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayeBattlePush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayeBattlePush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayeBattlePush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayeBattlePush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayeBattlePush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayeBattlePush";
  }
  protected:
  explicit PlayeBattlePush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBattleValueFieldNumber = 1,
  };
  // required int32 battleValue = 1;
  bool has_battlevalue() const;
  private:
  bool _internal_has_battlevalue() const;
  public:
  void clear_battlevalue();
  int32_t battlevalue() const;
  void set_battlevalue(int32_t value);
  private:
  int32_t _internal_battlevalue() const;
  void _internal_set_battlevalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayeBattlePush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t battlevalue_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class TalentPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TalentPush) */ {
 public:
  inline TalentPush() : TalentPush(nullptr) {}
  ~TalentPush() override;
  explicit PROTOBUF_CONSTEXPR TalentPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TalentPush(const TalentPush& from);
  TalentPush(TalentPush&& from) noexcept
    : TalentPush() {
    *this = ::std::move(from);
  }

  inline TalentPush& operator=(const TalentPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline TalentPush& operator=(TalentPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TalentPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const TalentPush* internal_default_instance() {
    return reinterpret_cast<const TalentPush*>(
               &_TalentPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TalentPush& a, TalentPush& b) {
    a.Swap(&b);
  }
  inline void Swap(TalentPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TalentPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TalentPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TalentPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TalentPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TalentPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TalentPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TalentPush";
  }
  protected:
  explicit TalentPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTalentIdsFieldNumber = 1,
  };
  // repeated int32 talentIds = 1;
  int talentids_size() const;
  private:
  int _internal_talentids_size() const;
  public:
  void clear_talentids();
  private:
  int32_t _internal_talentids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_talentids() const;
  void _internal_add_talentids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_talentids();
  public:
  int32_t talentids(int index) const;
  void set_talentids(int index, int32_t value);
  void add_talentids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      talentids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_talentids();

  // @@protoc_insertion_point(class_scope:TalentPush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > talentids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class VipInfoPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VipInfoPush) */ {
 public:
  inline VipInfoPush() : VipInfoPush(nullptr) {}
  ~VipInfoPush() override;
  explicit PROTOBUF_CONSTEXPR VipInfoPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VipInfoPush(const VipInfoPush& from);
  VipInfoPush(VipInfoPush&& from) noexcept
    : VipInfoPush() {
    *this = ::std::move(from);
  }

  inline VipInfoPush& operator=(const VipInfoPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline VipInfoPush& operator=(VipInfoPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VipInfoPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const VipInfoPush* internal_default_instance() {
    return reinterpret_cast<const VipInfoPush*>(
               &_VipInfoPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(VipInfoPush& a, VipInfoPush& b) {
    a.Swap(&b);
  }
  inline void Swap(VipInfoPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VipInfoPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VipInfoPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VipInfoPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VipInfoPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VipInfoPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VipInfoPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VipInfoPush";
  }
  protected:
  explicit VipInfoPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLvFieldNumber = 1,
    kExpFieldNumber = 2,
    kSignFieldNumber = 3,
  };
  // required int32 lv = 1;
  bool has_lv() const;
  private:
  bool _internal_has_lv() const;
  public:
  void clear_lv();
  int32_t lv() const;
  void set_lv(int32_t value);
  private:
  int32_t _internal_lv() const;
  void _internal_set_lv(int32_t value);
  public:

  // required int32 exp = 2;
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;
  public:
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // required int32 sign = 3;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  int32_t sign() const;
  void set_sign(int32_t value);
  private:
  int32_t _internal_sign() const;
  void _internal_set_sign(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VipInfoPush)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t lv_;
  int32_t exp_;
  int32_t sign_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class VipActiveInfoPush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VipActiveInfoPush) */ {
 public:
  inline VipActiveInfoPush() : VipActiveInfoPush(nullptr) {}
  ~VipActiveInfoPush() override;
  explicit PROTOBUF_CONSTEXPR VipActiveInfoPush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VipActiveInfoPush(const VipActiveInfoPush& from);
  VipActiveInfoPush(VipActiveInfoPush&& from) noexcept
    : VipActiveInfoPush() {
    *this = ::std::move(from);
  }

  inline VipActiveInfoPush& operator=(const VipActiveInfoPush& from) {
    CopyFrom(from);
    return *this;
  }
  inline VipActiveInfoPush& operator=(VipActiveInfoPush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VipActiveInfoPush& default_instance() {
    return *internal_default_instance();
  }
  static inline const VipActiveInfoPush* internal_default_instance() {
    return reinterpret_cast<const VipActiveInfoPush*>(
               &_VipActiveInfoPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(VipActiveInfoPush& a, VipActiveInfoPush& b) {
    a.Swap(&b);
  }
  inline void Swap(VipActiveInfoPush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VipActiveInfoPush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VipActiveInfoPush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VipActiveInfoPush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VipActiveInfoPush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VipActiveInfoPush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VipActiveInfoPush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VipActiveInfoPush";
  }
  protected:
  explicit VipActiveInfoPush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveEndFieldNumber = 1,
  };
  // required int32 activeEnd = 1;
  bool has_activeend() const;
  private:
  bool _internal_has_activeend() const;
  public:
  void clear_activeend();
  int32_t activeend() const;
  void set_activeend(int32_t value);
  private:
  int32_t _internal_activeend() const;
  void _internal_set_activeend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VipActiveInfoPush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t activeend_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SysTimePush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SysTimePush) */ {
 public:
  inline SysTimePush() : SysTimePush(nullptr) {}
  ~SysTimePush() override;
  explicit PROTOBUF_CONSTEXPR SysTimePush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SysTimePush(const SysTimePush& from);
  SysTimePush(SysTimePush&& from) noexcept
    : SysTimePush() {
    *this = ::std::move(from);
  }

  inline SysTimePush& operator=(const SysTimePush& from) {
    CopyFrom(from);
    return *this;
  }
  inline SysTimePush& operator=(SysTimePush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SysTimePush& default_instance() {
    return *internal_default_instance();
  }
  static inline const SysTimePush* internal_default_instance() {
    return reinterpret_cast<const SysTimePush*>(
               &_SysTimePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SysTimePush& a, SysTimePush& b) {
    a.Swap(&b);
  }
  inline void Swap(SysTimePush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SysTimePush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SysTimePush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SysTimePush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SysTimePush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SysTimePush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SysTimePush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SysTimePush";
  }
  protected:
  explicit SysTimePush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrTimeFieldNumber = 1,
  };
  // required int64 currTime = 1;
  bool has_currtime() const;
  private:
  bool _internal_has_currtime() const;
  public:
  void clear_currtime();
  int64_t currtime() const;
  void set_currtime(int64_t value);
  private:
  int64_t _internal_currtime() const;
  void _internal_set_currtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SysTimePush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t currtime_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GuidePush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuidePush) */ {
 public:
  inline GuidePush() : GuidePush(nullptr) {}
  ~GuidePush() override;
  explicit PROTOBUF_CONSTEXPR GuidePush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuidePush(const GuidePush& from);
  GuidePush(GuidePush&& from) noexcept
    : GuidePush() {
    *this = ::std::move(from);
  }

  inline GuidePush& operator=(const GuidePush& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuidePush& operator=(GuidePush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuidePush& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuidePush* internal_default_instance() {
    return reinterpret_cast<const GuidePush*>(
               &_GuidePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GuidePush& a, GuidePush& b) {
    a.Swap(&b);
  }
  inline void Swap(GuidePush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuidePush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuidePush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuidePush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuidePush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GuidePush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuidePush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuidePush";
  }
  protected:
  explicit GuidePush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuideFieldNumber = 1,
  };
  // required .GuideDTO guide = 1;
  bool has_guide() const;
  private:
  bool _internal_has_guide() const;
  public:
  void clear_guide();
  const ::GuideDTO& guide() const;
  PROTOBUF_NODISCARD ::GuideDTO* release_guide();
  ::GuideDTO* mutable_guide();
  void set_allocated_guide(::GuideDTO* guide);
  private:
  const ::GuideDTO& _internal_guide() const;
  ::GuideDTO* _internal_mutable_guide();
  public:
  void unsafe_arena_set_allocated_guide(
      ::GuideDTO* guide);
  ::GuideDTO* unsafe_arena_release_guide();

  // @@protoc_insertion_point(class_scope:GuidePush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::GuideDTO* guide_;
  friend struct ::TableStruct_player_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerDTO

// required uint64 playerId = 1;
inline bool PlayerDTO::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerDTO::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerDTO::clear_playerid() {
  playerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t PlayerDTO::_internal_playerid() const {
  return playerid_;
}
inline uint64_t PlayerDTO::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.playerId)
  return _internal_playerid();
}
inline void PlayerDTO::_internal_set_playerid(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  playerid_ = value;
}
inline void PlayerDTO::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayerDTO.playerId)
}

// optional string name = 2;
inline bool PlayerDTO::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerDTO::has_name() const {
  return _internal_has_name();
}
inline void PlayerDTO::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerDTO::name() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDTO::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerDTO.name)
}
inline std::string* PlayerDTO::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PlayerDTO.name)
  return _s;
}
inline const std::string& PlayerDTO::_internal_name() const {
  return name_.Get();
}
inline void PlayerDTO::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDTO::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDTO::release_name() {
  // @@protoc_insertion_point(field_release:PlayerDTO.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerDTO::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerDTO.name)
}

// required int32 level = 3;
inline bool PlayerDTO::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerDTO::has_level() const {
  return _internal_has_level();
}
inline void PlayerDTO::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t PlayerDTO::_internal_level() const {
  return level_;
}
inline int32_t PlayerDTO::level() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.level)
  return _internal_level();
}
inline void PlayerDTO::_internal_set_level(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  level_ = value;
}
inline void PlayerDTO::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:PlayerDTO.level)
}

// repeated .PropertyDTO properties = 4;
inline int PlayerDTO::_internal_properties_size() const {
  return properties_.size();
}
inline int PlayerDTO::properties_size() const {
  return _internal_properties_size();
}
inline ::PropertyDTO* PlayerDTO::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerDTO.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >*
PlayerDTO::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:PlayerDTO.properties)
  return &properties_;
}
inline const ::PropertyDTO& PlayerDTO::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::PropertyDTO& PlayerDTO::properties(int index) const {
  // @@protoc_insertion_point(field_get:PlayerDTO.properties)
  return _internal_properties(index);
}
inline ::PropertyDTO* PlayerDTO::_internal_add_properties() {
  return properties_.Add();
}
inline ::PropertyDTO* PlayerDTO::add_properties() {
  ::PropertyDTO* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:PlayerDTO.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >&
PlayerDTO::properties() const {
  // @@protoc_insertion_point(field_list:PlayerDTO.properties)
  return properties_;
}

// optional string language = 5;
inline bool PlayerDTO::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerDTO::has_language() const {
  return _internal_has_language();
}
inline void PlayerDTO::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PlayerDTO::language() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDTO::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerDTO.language)
}
inline std::string* PlayerDTO::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:PlayerDTO.language)
  return _s;
}
inline const std::string& PlayerDTO::_internal_language() const {
  return language_.Get();
}
inline void PlayerDTO::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDTO::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDTO::release_language() {
  // @@protoc_insertion_point(field_release:PlayerDTO.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerDTO::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerDTO.language)
}

// required .PositionDTO mapGridPosition = 6;
inline bool PlayerDTO::_internal_has_mapgridposition() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || mapgridposition_ != nullptr);
  return value;
}
inline bool PlayerDTO::has_mapgridposition() const {
  return _internal_has_mapgridposition();
}
inline const ::PositionDTO& PlayerDTO::_internal_mapgridposition() const {
  const ::PositionDTO* p = mapgridposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::PositionDTO&>(
      ::_PositionDTO_default_instance_);
}
inline const ::PositionDTO& PlayerDTO::mapgridposition() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.mapGridPosition)
  return _internal_mapgridposition();
}
inline void PlayerDTO::unsafe_arena_set_allocated_mapgridposition(
    ::PositionDTO* mapgridposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapgridposition_);
  }
  mapgridposition_ = mapgridposition;
  if (mapgridposition) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerDTO.mapGridPosition)
}
inline ::PositionDTO* PlayerDTO::release_mapgridposition() {
  _has_bits_[0] &= ~0x00000008u;
  ::PositionDTO* temp = mapgridposition_;
  mapgridposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PositionDTO* PlayerDTO::unsafe_arena_release_mapgridposition() {
  // @@protoc_insertion_point(field_release:PlayerDTO.mapGridPosition)
  _has_bits_[0] &= ~0x00000008u;
  ::PositionDTO* temp = mapgridposition_;
  mapgridposition_ = nullptr;
  return temp;
}
inline ::PositionDTO* PlayerDTO::_internal_mutable_mapgridposition() {
  _has_bits_[0] |= 0x00000008u;
  if (mapgridposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::PositionDTO>(GetArenaForAllocation());
    mapgridposition_ = p;
  }
  return mapgridposition_;
}
inline ::PositionDTO* PlayerDTO::mutable_mapgridposition() {
  ::PositionDTO* _msg = _internal_mutable_mapgridposition();
  // @@protoc_insertion_point(field_mutable:PlayerDTO.mapGridPosition)
  return _msg;
}
inline void PlayerDTO::set_allocated_mapgridposition(::PositionDTO* mapgridposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapgridposition_);
  }
  if (mapgridposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapgridposition));
    if (message_arena != submessage_arena) {
      mapgridposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapgridposition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mapgridposition_ = mapgridposition;
  // @@protoc_insertion_point(field_set_allocated:PlayerDTO.mapGridPosition)
}

// required bool hasChangedName = 7;
inline bool PlayerDTO::_internal_has_haschangedname() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayerDTO::has_haschangedname() const {
  return _internal_has_haschangedname();
}
inline void PlayerDTO::clear_haschangedname() {
  haschangedname_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool PlayerDTO::_internal_haschangedname() const {
  return haschangedname_;
}
inline bool PlayerDTO::haschangedname() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.hasChangedName)
  return _internal_haschangedname();
}
inline void PlayerDTO::_internal_set_haschangedname(bool value) {
  _has_bits_[0] |= 0x00000040u;
  haschangedname_ = value;
}
inline void PlayerDTO::set_haschangedname(bool value) {
  _internal_set_haschangedname(value);
  // @@protoc_insertion_point(field_set:PlayerDTO.hasChangedName)
}

// required string icon = 8;
inline bool PlayerDTO::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerDTO::has_icon() const {
  return _internal_has_icon();
}
inline void PlayerDTO::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PlayerDTO::icon() const {
  // @@protoc_insertion_point(field_get:PlayerDTO.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDTO::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 icon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerDTO.icon)
}
inline std::string* PlayerDTO::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:PlayerDTO.icon)
  return _s;
}
inline const std::string& PlayerDTO::_internal_icon() const {
  return icon_.Get();
}
inline void PlayerDTO::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  icon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDTO::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000004u;
  return icon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDTO::release_icon() {
  // @@protoc_insertion_point(field_release:PlayerDTO.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = icon_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerDTO::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerDTO.icon)
}

// -------------------------------------------------------------------

// GuideDTO

// required int32 id = 2;
inline bool GuideDTO::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuideDTO::has_id() const {
  return _internal_has_id();
}
inline void GuideDTO::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t GuideDTO::_internal_id() const {
  return id_;
}
inline int32_t GuideDTO::id() const {
  // @@protoc_insertion_point(field_get:GuideDTO.id)
  return _internal_id();
}
inline void GuideDTO::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void GuideDTO::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:GuideDTO.id)
}

// required bool jump = 3;
inline bool GuideDTO::_internal_has_jump() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuideDTO::has_jump() const {
  return _internal_has_jump();
}
inline void GuideDTO::clear_jump() {
  jump_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GuideDTO::_internal_jump() const {
  return jump_;
}
inline bool GuideDTO::jump() const {
  // @@protoc_insertion_point(field_get:GuideDTO.jump)
  return _internal_jump();
}
inline void GuideDTO::_internal_set_jump(bool value) {
  _has_bits_[0] |= 0x00000002u;
  jump_ = value;
}
inline void GuideDTO::set_jump(bool value) {
  _internal_set_jump(value);
  // @@protoc_insertion_point(field_set:GuideDTO.jump)
}

// -------------------------------------------------------------------

// UserAccountLoginRequest

// required string platform = 1;
inline bool UserAccountLoginRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserAccountLoginRequest::has_platform() const {
  return _internal_has_platform();
}
inline void UserAccountLoginRequest::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserAccountLoginRequest::platform() const {
  // @@protoc_insertion_point(field_get:UserAccountLoginRequest.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAccountLoginRequest::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserAccountLoginRequest.platform)
}
inline std::string* UserAccountLoginRequest::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:UserAccountLoginRequest.platform)
  return _s;
}
inline const std::string& UserAccountLoginRequest::_internal_platform() const {
  return platform_.Get();
}
inline void UserAccountLoginRequest::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAccountLoginRequest::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000001u;
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAccountLoginRequest::release_platform() {
  // @@protoc_insertion_point(field_release:UserAccountLoginRequest.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = platform_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserAccountLoginRequest::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountLoginRequest.platform)
}

// required string puid = 2;
inline bool UserAccountLoginRequest::_internal_has_puid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserAccountLoginRequest::has_puid() const {
  return _internal_has_puid();
}
inline void UserAccountLoginRequest::clear_puid() {
  puid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserAccountLoginRequest::puid() const {
  // @@protoc_insertion_point(field_get:UserAccountLoginRequest.puid)
  return _internal_puid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAccountLoginRequest::set_puid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 puid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserAccountLoginRequest.puid)
}
inline std::string* UserAccountLoginRequest::mutable_puid() {
  std::string* _s = _internal_mutable_puid();
  // @@protoc_insertion_point(field_mutable:UserAccountLoginRequest.puid)
  return _s;
}
inline const std::string& UserAccountLoginRequest::_internal_puid() const {
  return puid_.Get();
}
inline void UserAccountLoginRequest::_internal_set_puid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  puid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAccountLoginRequest::_internal_mutable_puid() {
  _has_bits_[0] |= 0x00000002u;
  return puid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAccountLoginRequest::release_puid() {
  // @@protoc_insertion_point(field_release:UserAccountLoginRequest.puid)
  if (!_internal_has_puid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = puid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (puid_.IsDefault()) {
    puid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserAccountLoginRequest::set_allocated_puid(std::string* puid) {
  if (puid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  puid_.SetAllocated(puid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (puid_.IsDefault()) {
    puid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountLoginRequest.puid)
}

// -------------------------------------------------------------------

// UserAccountLoginResponse

// required uint64 playerId = 1;
inline bool UserAccountLoginResponse::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserAccountLoginResponse::has_playerid() const {
  return _internal_has_playerid();
}
inline void UserAccountLoginResponse::clear_playerid() {
  playerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t UserAccountLoginResponse::_internal_playerid() const {
  return playerid_;
}
inline uint64_t UserAccountLoginResponse::playerid() const {
  // @@protoc_insertion_point(field_get:UserAccountLoginResponse.playerId)
  return _internal_playerid();
}
inline void UserAccountLoginResponse::_internal_set_playerid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void UserAccountLoginResponse::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:UserAccountLoginResponse.playerId)
}

// -------------------------------------------------------------------

// PlayerLoginRequest

// required uint64 playerId = 1;
inline bool PlayerLoginRequest::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerLoginRequest::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerLoginRequest::clear_playerid() {
  playerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PlayerLoginRequest::_internal_playerid() const {
  return playerid_;
}
inline uint64_t PlayerLoginRequest::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerLoginRequest.playerId)
  return _internal_playerid();
}
inline void PlayerLoginRequest::_internal_set_playerid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void PlayerLoginRequest::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayerLoginRequest.playerId)
}

// -------------------------------------------------------------------

// PlayerLoginResponse

// required uint64 sessionId = 1;
inline bool PlayerLoginResponse::_internal_has_sessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerLoginResponse::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void PlayerLoginResponse::clear_sessionid() {
  sessionid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PlayerLoginResponse::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t PlayerLoginResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:PlayerLoginResponse.sessionId)
  return _internal_sessionid();
}
inline void PlayerLoginResponse::_internal_set_sessionid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  sessionid_ = value;
}
inline void PlayerLoginResponse::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:PlayerLoginResponse.sessionId)
}

// required int64 systime = 2;
inline bool PlayerLoginResponse::_internal_has_systime() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerLoginResponse::has_systime() const {
  return _internal_has_systime();
}
inline void PlayerLoginResponse::clear_systime() {
  systime_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t PlayerLoginResponse::_internal_systime() const {
  return systime_;
}
inline int64_t PlayerLoginResponse::systime() const {
  // @@protoc_insertion_point(field_get:PlayerLoginResponse.systime)
  return _internal_systime();
}
inline void PlayerLoginResponse::_internal_set_systime(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  systime_ = value;
}
inline void PlayerLoginResponse::set_systime(int64_t value) {
  _internal_set_systime(value);
  // @@protoc_insertion_point(field_set:PlayerLoginResponse.systime)
}

// required int32 timeZoneOffset = 3;
inline bool PlayerLoginResponse::_internal_has_timezoneoffset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerLoginResponse::has_timezoneoffset() const {
  return _internal_has_timezoneoffset();
}
inline void PlayerLoginResponse::clear_timezoneoffset() {
  timezoneoffset_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t PlayerLoginResponse::_internal_timezoneoffset() const {
  return timezoneoffset_;
}
inline int32_t PlayerLoginResponse::timezoneoffset() const {
  // @@protoc_insertion_point(field_get:PlayerLoginResponse.timeZoneOffset)
  return _internal_timezoneoffset();
}
inline void PlayerLoginResponse::_internal_set_timezoneoffset(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  timezoneoffset_ = value;
}
inline void PlayerLoginResponse::set_timezoneoffset(int32_t value) {
  _internal_set_timezoneoffset(value);
  // @@protoc_insertion_point(field_set:PlayerLoginResponse.timeZoneOffset)
}

// -------------------------------------------------------------------

// PlayerReconnectRequest

// required uint64 sessionId = 1;
inline bool PlayerReconnectRequest::_internal_has_sessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerReconnectRequest::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void PlayerReconnectRequest::clear_sessionid() {
  sessionid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PlayerReconnectRequest::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t PlayerReconnectRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:PlayerReconnectRequest.sessionId)
  return _internal_sessionid();
}
inline void PlayerReconnectRequest::_internal_set_sessionid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  sessionid_ = value;
}
inline void PlayerReconnectRequest::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:PlayerReconnectRequest.sessionId)
}

// required int32 lastPushId = 2;
inline bool PlayerReconnectRequest::_internal_has_lastpushid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerReconnectRequest::has_lastpushid() const {
  return _internal_has_lastpushid();
}
inline void PlayerReconnectRequest::clear_lastpushid() {
  lastpushid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t PlayerReconnectRequest::_internal_lastpushid() const {
  return lastpushid_;
}
inline int32_t PlayerReconnectRequest::lastpushid() const {
  // @@protoc_insertion_point(field_get:PlayerReconnectRequest.lastPushId)
  return _internal_lastpushid();
}
inline void PlayerReconnectRequest::_internal_set_lastpushid(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  lastpushid_ = value;
}
inline void PlayerReconnectRequest::set_lastpushid(int32_t value) {
  _internal_set_lastpushid(value);
  // @@protoc_insertion_point(field_set:PlayerReconnectRequest.lastPushId)
}

// -------------------------------------------------------------------

// PlayerReconnectResponse

// optional .ReconnectState state = 1;
inline bool PlayerReconnectResponse::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerReconnectResponse::has_state() const {
  return _internal_has_state();
}
inline void PlayerReconnectResponse::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ReconnectState PlayerReconnectResponse::_internal_state() const {
  return static_cast< ::ReconnectState >(state_);
}
inline ::ReconnectState PlayerReconnectResponse::state() const {
  // @@protoc_insertion_point(field_get:PlayerReconnectResponse.state)
  return _internal_state();
}
inline void PlayerReconnectResponse::_internal_set_state(::ReconnectState value) {
  assert(::ReconnectState_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void PlayerReconnectResponse::set_state(::ReconnectState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:PlayerReconnectResponse.state)
}

// -------------------------------------------------------------------

// PlayerReloadRequest

// -------------------------------------------------------------------

// PlayerReloadResponse

// required int64 systime = 1;
inline bool PlayerReloadResponse::_internal_has_systime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerReloadResponse::has_systime() const {
  return _internal_has_systime();
}
inline void PlayerReloadResponse::clear_systime() {
  systime_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t PlayerReloadResponse::_internal_systime() const {
  return systime_;
}
inline int64_t PlayerReloadResponse::systime() const {
  // @@protoc_insertion_point(field_get:PlayerReloadResponse.systime)
  return _internal_systime();
}
inline void PlayerReloadResponse::_internal_set_systime(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  systime_ = value;
}
inline void PlayerReloadResponse::set_systime(int64_t value) {
  _internal_set_systime(value);
  // @@protoc_insertion_point(field_set:PlayerReloadResponse.systime)
}

// required int32 timeZoneOffset = 2;
inline bool PlayerReloadResponse::_internal_has_timezoneoffset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerReloadResponse::has_timezoneoffset() const {
  return _internal_has_timezoneoffset();
}
inline void PlayerReloadResponse::clear_timezoneoffset() {
  timezoneoffset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t PlayerReloadResponse::_internal_timezoneoffset() const {
  return timezoneoffset_;
}
inline int32_t PlayerReloadResponse::timezoneoffset() const {
  // @@protoc_insertion_point(field_get:PlayerReloadResponse.timeZoneOffset)
  return _internal_timezoneoffset();
}
inline void PlayerReloadResponse::_internal_set_timezoneoffset(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timezoneoffset_ = value;
}
inline void PlayerReloadResponse::set_timezoneoffset(int32_t value) {
  _internal_set_timezoneoffset(value);
  // @@protoc_insertion_point(field_set:PlayerReloadResponse.timeZoneOffset)
}

// -------------------------------------------------------------------

// PlayerHeartBeatRequest

// -------------------------------------------------------------------

// PlayerHeartBeatResponse

// required int64 systime = 1;
inline bool PlayerHeartBeatResponse::_internal_has_systime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerHeartBeatResponse::has_systime() const {
  return _internal_has_systime();
}
inline void PlayerHeartBeatResponse::clear_systime() {
  systime_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t PlayerHeartBeatResponse::_internal_systime() const {
  return systime_;
}
inline int64_t PlayerHeartBeatResponse::systime() const {
  // @@protoc_insertion_point(field_get:PlayerHeartBeatResponse.systime)
  return _internal_systime();
}
inline void PlayerHeartBeatResponse::_internal_set_systime(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  systime_ = value;
}
inline void PlayerHeartBeatResponse::set_systime(int64_t value) {
  _internal_set_systime(value);
  // @@protoc_insertion_point(field_set:PlayerHeartBeatResponse.systime)
}

// -------------------------------------------------------------------

// SetTalentRequest

// required int32 level = 1;
inline bool SetTalentRequest::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetTalentRequest::has_level() const {
  return _internal_has_level();
}
inline void SetTalentRequest::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SetTalentRequest::_internal_level() const {
  return level_;
}
inline int32_t SetTalentRequest::level() const {
  // @@protoc_insertion_point(field_get:SetTalentRequest.level)
  return _internal_level();
}
inline void SetTalentRequest::_internal_set_level(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  level_ = value;
}
inline void SetTalentRequest::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:SetTalentRequest.level)
}

// required int32 talentId = 2;
inline bool SetTalentRequest::_internal_has_talentid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetTalentRequest::has_talentid() const {
  return _internal_has_talentid();
}
inline void SetTalentRequest::clear_talentid() {
  talentid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SetTalentRequest::_internal_talentid() const {
  return talentid_;
}
inline int32_t SetTalentRequest::talentid() const {
  // @@protoc_insertion_point(field_get:SetTalentRequest.talentId)
  return _internal_talentid();
}
inline void SetTalentRequest::_internal_set_talentid(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  talentid_ = value;
}
inline void SetTalentRequest::set_talentid(int32_t value) {
  _internal_set_talentid(value);
  // @@protoc_insertion_point(field_set:SetTalentRequest.talentId)
}

// -------------------------------------------------------------------

// SetTalentResponse

// required int32 level = 1;
inline bool SetTalentResponse::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetTalentResponse::has_level() const {
  return _internal_has_level();
}
inline void SetTalentResponse::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SetTalentResponse::_internal_level() const {
  return level_;
}
inline int32_t SetTalentResponse::level() const {
  // @@protoc_insertion_point(field_get:SetTalentResponse.level)
  return _internal_level();
}
inline void SetTalentResponse::_internal_set_level(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  level_ = value;
}
inline void SetTalentResponse::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:SetTalentResponse.level)
}

// required int32 talentId = 2;
inline bool SetTalentResponse::_internal_has_talentid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetTalentResponse::has_talentid() const {
  return _internal_has_talentid();
}
inline void SetTalentResponse::clear_talentid() {
  talentid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SetTalentResponse::_internal_talentid() const {
  return talentid_;
}
inline int32_t SetTalentResponse::talentid() const {
  // @@protoc_insertion_point(field_get:SetTalentResponse.talentId)
  return _internal_talentid();
}
inline void SetTalentResponse::_internal_set_talentid(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  talentid_ = value;
}
inline void SetTalentResponse::set_talentid(int32_t value) {
  _internal_set_talentid(value);
  // @@protoc_insertion_point(field_set:SetTalentResponse.talentId)
}

// -------------------------------------------------------------------

// SetImageRequest

// required int32 image = 1;
inline bool SetImageRequest::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetImageRequest::has_image() const {
  return _internal_has_image();
}
inline void SetImageRequest::clear_image() {
  image_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SetImageRequest::_internal_image() const {
  return image_;
}
inline int32_t SetImageRequest::image() const {
  // @@protoc_insertion_point(field_get:SetImageRequest.image)
  return _internal_image();
}
inline void SetImageRequest::_internal_set_image(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  image_ = value;
}
inline void SetImageRequest::set_image(int32_t value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:SetImageRequest.image)
}

// -------------------------------------------------------------------

// SetImageResponse

// optional int32 image = 2;
inline bool SetImageResponse::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetImageResponse::has_image() const {
  return _internal_has_image();
}
inline void SetImageResponse::clear_image() {
  image_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SetImageResponse::_internal_image() const {
  return image_;
}
inline int32_t SetImageResponse::image() const {
  // @@protoc_insertion_point(field_get:SetImageResponse.image)
  return _internal_image();
}
inline void SetImageResponse::_internal_set_image(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  image_ = value;
}
inline void SetImageResponse::set_image(int32_t value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:SetImageResponse.image)
}

// -------------------------------------------------------------------

// QueryLordInfoRequest

// optional int64 playerId = 1;
inline bool QueryLordInfoRequest::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryLordInfoRequest::has_playerid() const {
  return _internal_has_playerid();
}
inline void QueryLordInfoRequest::clear_playerid() {
  playerid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t QueryLordInfoRequest::_internal_playerid() const {
  return playerid_;
}
inline int64_t QueryLordInfoRequest::playerid() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoRequest.playerId)
  return _internal_playerid();
}
inline void QueryLordInfoRequest::_internal_set_playerid(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void QueryLordInfoRequest::set_playerid(int64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoRequest.playerId)
}

// optional string name = 2;
inline bool QueryLordInfoRequest::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryLordInfoRequest::has_name() const {
  return _internal_has_name();
}
inline void QueryLordInfoRequest::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryLordInfoRequest::name() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLordInfoRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLordInfoRequest.name)
}
inline std::string* QueryLordInfoRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:QueryLordInfoRequest.name)
  return _s;
}
inline const std::string& QueryLordInfoRequest::_internal_name() const {
  return name_.Get();
}
inline void QueryLordInfoRequest::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLordInfoRequest::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryLordInfoRequest::release_name() {
  // @@protoc_insertion_point(field_release:QueryLordInfoRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLordInfoRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLordInfoRequest.name)
}

// -------------------------------------------------------------------

// QueryLordInfoResponse

// optional int64 playerId = 1;
inline bool QueryLordInfoResponse::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_playerid() const {
  return _internal_has_playerid();
}
inline void QueryLordInfoResponse::clear_playerid() {
  playerid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t QueryLordInfoResponse::_internal_playerid() const {
  return playerid_;
}
inline int64_t QueryLordInfoResponse::playerid() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.playerId)
  return _internal_playerid();
}
inline void QueryLordInfoResponse::_internal_set_playerid(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  playerid_ = value;
}
inline void QueryLordInfoResponse::set_playerid(int64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.playerId)
}

// optional string nickname = 2;
inline bool QueryLordInfoResponse::_internal_has_nickname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_nickname() const {
  return _internal_has_nickname();
}
inline void QueryLordInfoResponse::clear_nickname() {
  nickname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryLordInfoResponse::nickname() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLordInfoResponse::set_nickname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.nickname)
}
inline std::string* QueryLordInfoResponse::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:QueryLordInfoResponse.nickname)
  return _s;
}
inline const std::string& QueryLordInfoResponse::_internal_nickname() const {
  return nickname_.Get();
}
inline void QueryLordInfoResponse::_internal_set_nickname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLordInfoResponse::_internal_mutable_nickname() {
  _has_bits_[0] |= 0x00000001u;
  return nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryLordInfoResponse::release_nickname() {
  // @@protoc_insertion_point(field_release:QueryLordInfoResponse.nickname)
  if (!_internal_has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = nickname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLordInfoResponse::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLordInfoResponse.nickname)
}

// optional int32 allianceid = 3;
inline bool QueryLordInfoResponse::_internal_has_allianceid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_allianceid() const {
  return _internal_has_allianceid();
}
inline void QueryLordInfoResponse::clear_allianceid() {
  allianceid_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t QueryLordInfoResponse::_internal_allianceid() const {
  return allianceid_;
}
inline int32_t QueryLordInfoResponse::allianceid() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.allianceid)
  return _internal_allianceid();
}
inline void QueryLordInfoResponse::_internal_set_allianceid(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  allianceid_ = value;
}
inline void QueryLordInfoResponse::set_allianceid(int32_t value) {
  _internal_set_allianceid(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.allianceid)
}

// optional string alliancename = 4;
inline bool QueryLordInfoResponse::_internal_has_alliancename() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_alliancename() const {
  return _internal_has_alliancename();
}
inline void QueryLordInfoResponse::clear_alliancename() {
  alliancename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryLordInfoResponse::alliancename() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.alliancename)
  return _internal_alliancename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLordInfoResponse::set_alliancename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 alliancename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.alliancename)
}
inline std::string* QueryLordInfoResponse::mutable_alliancename() {
  std::string* _s = _internal_mutable_alliancename();
  // @@protoc_insertion_point(field_mutable:QueryLordInfoResponse.alliancename)
  return _s;
}
inline const std::string& QueryLordInfoResponse::_internal_alliancename() const {
  return alliancename_.Get();
}
inline void QueryLordInfoResponse::_internal_set_alliancename(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  alliancename_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLordInfoResponse::_internal_mutable_alliancename() {
  _has_bits_[0] |= 0x00000002u;
  return alliancename_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryLordInfoResponse::release_alliancename() {
  // @@protoc_insertion_point(field_release:QueryLordInfoResponse.alliancename)
  if (!_internal_has_alliancename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = alliancename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alliancename_.IsDefault()) {
    alliancename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLordInfoResponse::set_allocated_alliancename(std::string* alliancename) {
  if (alliancename != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  alliancename_.SetAllocated(alliancename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alliancename_.IsDefault()) {
    alliancename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLordInfoResponse.alliancename)
}

// optional int32 exp = 5;
inline bool QueryLordInfoResponse::_internal_has_exp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_exp() const {
  return _internal_has_exp();
}
inline void QueryLordInfoResponse::clear_exp() {
  exp_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t QueryLordInfoResponse::_internal_exp() const {
  return exp_;
}
inline int32_t QueryLordInfoResponse::exp() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.exp)
  return _internal_exp();
}
inline void QueryLordInfoResponse::_internal_set_exp(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  exp_ = value;
}
inline void QueryLordInfoResponse::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.exp)
}

// optional int32 level = 6;
inline bool QueryLordInfoResponse::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_level() const {
  return _internal_has_level();
}
inline void QueryLordInfoResponse::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t QueryLordInfoResponse::_internal_level() const {
  return level_;
}
inline int32_t QueryLordInfoResponse::level() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.level)
  return _internal_level();
}
inline void QueryLordInfoResponse::_internal_set_level(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  level_ = value;
}
inline void QueryLordInfoResponse::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.level)
}

// optional bool isfriend = 7;
inline bool QueryLordInfoResponse::_internal_has_isfriend() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_isfriend() const {
  return _internal_has_isfriend();
}
inline void QueryLordInfoResponse::clear_isfriend() {
  isfriend_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool QueryLordInfoResponse::_internal_isfriend() const {
  return isfriend_;
}
inline bool QueryLordInfoResponse::isfriend() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.isfriend)
  return _internal_isfriend();
}
inline void QueryLordInfoResponse::_internal_set_isfriend(bool value) {
  _has_bits_[0] |= 0x00000040u;
  isfriend_ = value;
}
inline void QueryLordInfoResponse::set_isfriend(bool value) {
  _internal_set_isfriend(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.isfriend)
}

// optional int32 image = 8;
inline bool QueryLordInfoResponse::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryLordInfoResponse::has_image() const {
  return _internal_has_image();
}
inline void QueryLordInfoResponse::clear_image() {
  image_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t QueryLordInfoResponse::_internal_image() const {
  return image_;
}
inline int32_t QueryLordInfoResponse::image() const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.image)
  return _internal_image();
}
inline void QueryLordInfoResponse::_internal_set_image(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  image_ = value;
}
inline void QueryLordInfoResponse::set_image(int32_t value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:QueryLordInfoResponse.image)
}

// repeated .EquipmentDTO equipmentlist = 9;
inline int QueryLordInfoResponse::_internal_equipmentlist_size() const {
  return equipmentlist_.size();
}
inline int QueryLordInfoResponse::equipmentlist_size() const {
  return _internal_equipmentlist_size();
}
inline ::EquipmentDTO* QueryLordInfoResponse::mutable_equipmentlist(int index) {
  // @@protoc_insertion_point(field_mutable:QueryLordInfoResponse.equipmentlist)
  return equipmentlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EquipmentDTO >*
QueryLordInfoResponse::mutable_equipmentlist() {
  // @@protoc_insertion_point(field_mutable_list:QueryLordInfoResponse.equipmentlist)
  return &equipmentlist_;
}
inline const ::EquipmentDTO& QueryLordInfoResponse::_internal_equipmentlist(int index) const {
  return equipmentlist_.Get(index);
}
inline const ::EquipmentDTO& QueryLordInfoResponse::equipmentlist(int index) const {
  // @@protoc_insertion_point(field_get:QueryLordInfoResponse.equipmentlist)
  return _internal_equipmentlist(index);
}
inline ::EquipmentDTO* QueryLordInfoResponse::_internal_add_equipmentlist() {
  return equipmentlist_.Add();
}
inline ::EquipmentDTO* QueryLordInfoResponse::add_equipmentlist() {
  ::EquipmentDTO* _add = _internal_add_equipmentlist();
  // @@protoc_insertion_point(field_add:QueryLordInfoResponse.equipmentlist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EquipmentDTO >&
QueryLordInfoResponse::equipmentlist() const {
  // @@protoc_insertion_point(field_list:QueryLordInfoResponse.equipmentlist)
  return equipmentlist_;
}

// -------------------------------------------------------------------

// SetIconRequest

// required string iconID = 1;
inline bool SetIconRequest::_internal_has_iconid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetIconRequest::has_iconid() const {
  return _internal_has_iconid();
}
inline void SetIconRequest::clear_iconid() {
  iconid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetIconRequest::iconid() const {
  // @@protoc_insertion_point(field_get:SetIconRequest.iconID)
  return _internal_iconid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetIconRequest::set_iconid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 iconid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetIconRequest.iconID)
}
inline std::string* SetIconRequest::mutable_iconid() {
  std::string* _s = _internal_mutable_iconid();
  // @@protoc_insertion_point(field_mutable:SetIconRequest.iconID)
  return _s;
}
inline const std::string& SetIconRequest::_internal_iconid() const {
  return iconid_.Get();
}
inline void SetIconRequest::_internal_set_iconid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iconid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetIconRequest::_internal_mutable_iconid() {
  _has_bits_[0] |= 0x00000001u;
  return iconid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetIconRequest::release_iconid() {
  // @@protoc_insertion_point(field_release:SetIconRequest.iconID)
  if (!_internal_has_iconid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = iconid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconid_.IsDefault()) {
    iconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetIconRequest::set_allocated_iconid(std::string* iconid) {
  if (iconid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iconid_.SetAllocated(iconid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconid_.IsDefault()) {
    iconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SetIconRequest.iconID)
}

// required int32 oper = 2;
inline bool SetIconRequest::_internal_has_oper() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetIconRequest::has_oper() const {
  return _internal_has_oper();
}
inline void SetIconRequest::clear_oper() {
  oper_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SetIconRequest::_internal_oper() const {
  return oper_;
}
inline int32_t SetIconRequest::oper() const {
  // @@protoc_insertion_point(field_get:SetIconRequest.oper)
  return _internal_oper();
}
inline void SetIconRequest::_internal_set_oper(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  oper_ = value;
}
inline void SetIconRequest::set_oper(int32_t value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:SetIconRequest.oper)
}

// -------------------------------------------------------------------

// SetIconResponse

// optional string iconID = 2;
inline bool SetIconResponse::_internal_has_iconid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetIconResponse::has_iconid() const {
  return _internal_has_iconid();
}
inline void SetIconResponse::clear_iconid() {
  iconid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetIconResponse::iconid() const {
  // @@protoc_insertion_point(field_get:SetIconResponse.iconID)
  return _internal_iconid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetIconResponse::set_iconid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 iconid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetIconResponse.iconID)
}
inline std::string* SetIconResponse::mutable_iconid() {
  std::string* _s = _internal_mutable_iconid();
  // @@protoc_insertion_point(field_mutable:SetIconResponse.iconID)
  return _s;
}
inline const std::string& SetIconResponse::_internal_iconid() const {
  return iconid_.Get();
}
inline void SetIconResponse::_internal_set_iconid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iconid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetIconResponse::_internal_mutable_iconid() {
  _has_bits_[0] |= 0x00000001u;
  return iconid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetIconResponse::release_iconid() {
  // @@protoc_insertion_point(field_release:SetIconResponse.iconID)
  if (!_internal_has_iconid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = iconid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconid_.IsDefault()) {
    iconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetIconResponse::set_allocated_iconid(std::string* iconid) {
  if (iconid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iconid_.SetAllocated(iconid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconid_.IsDefault()) {
    iconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SetIconResponse.iconID)
}

// -------------------------------------------------------------------

// ChangeNameRequest

// required string nickname = 1;
inline bool ChangeNameRequest::_internal_has_nickname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeNameRequest::has_nickname() const {
  return _internal_has_nickname();
}
inline void ChangeNameRequest::clear_nickname() {
  nickname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeNameRequest::nickname() const {
  // @@protoc_insertion_point(field_get:ChangeNameRequest.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeNameRequest::set_nickname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChangeNameRequest.nickname)
}
inline std::string* ChangeNameRequest::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:ChangeNameRequest.nickname)
  return _s;
}
inline const std::string& ChangeNameRequest::_internal_nickname() const {
  return nickname_.Get();
}
inline void ChangeNameRequest::_internal_set_nickname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeNameRequest::_internal_mutable_nickname() {
  _has_bits_[0] |= 0x00000001u;
  return nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeNameRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:ChangeNameRequest.nickname)
  if (!_internal_has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = nickname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeNameRequest::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChangeNameRequest.nickname)
}

// required bool useItem = 2;
inline bool ChangeNameRequest::_internal_has_useitem() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeNameRequest::has_useitem() const {
  return _internal_has_useitem();
}
inline void ChangeNameRequest::clear_useitem() {
  useitem_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ChangeNameRequest::_internal_useitem() const {
  return useitem_;
}
inline bool ChangeNameRequest::useitem() const {
  // @@protoc_insertion_point(field_get:ChangeNameRequest.useItem)
  return _internal_useitem();
}
inline void ChangeNameRequest::_internal_set_useitem(bool value) {
  _has_bits_[0] |= 0x00000002u;
  useitem_ = value;
}
inline void ChangeNameRequest::set_useitem(bool value) {
  _internal_set_useitem(value);
  // @@protoc_insertion_point(field_set:ChangeNameRequest.useItem)
}

// -------------------------------------------------------------------

// ChangeNameResponse

// required bool isAvailable = 1;
inline bool ChangeNameResponse::_internal_has_isavailable() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeNameResponse::has_isavailable() const {
  return _internal_has_isavailable();
}
inline void ChangeNameResponse::clear_isavailable() {
  isavailable_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ChangeNameResponse::_internal_isavailable() const {
  return isavailable_;
}
inline bool ChangeNameResponse::isavailable() const {
  // @@protoc_insertion_point(field_get:ChangeNameResponse.isAvailable)
  return _internal_isavailable();
}
inline void ChangeNameResponse::_internal_set_isavailable(bool value) {
  _has_bits_[0] |= 0x00000002u;
  isavailable_ = value;
}
inline void ChangeNameResponse::set_isavailable(bool value) {
  _internal_set_isavailable(value);
  // @@protoc_insertion_point(field_set:ChangeNameResponse.isAvailable)
}

// optional .PropertyDTO reward = 2;
inline bool ChangeNameResponse::_internal_has_reward() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || reward_ != nullptr);
  return value;
}
inline bool ChangeNameResponse::has_reward() const {
  return _internal_has_reward();
}
inline const ::PropertyDTO& ChangeNameResponse::_internal_reward() const {
  const ::PropertyDTO* p = reward_;
  return p != nullptr ? *p : reinterpret_cast<const ::PropertyDTO&>(
      ::_PropertyDTO_default_instance_);
}
inline const ::PropertyDTO& ChangeNameResponse::reward() const {
  // @@protoc_insertion_point(field_get:ChangeNameResponse.reward)
  return _internal_reward();
}
inline void ChangeNameResponse::unsafe_arena_set_allocated_reward(
    ::PropertyDTO* reward) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reward_);
  }
  reward_ = reward;
  if (reward) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChangeNameResponse.reward)
}
inline ::PropertyDTO* ChangeNameResponse::release_reward() {
  _has_bits_[0] &= ~0x00000001u;
  ::PropertyDTO* temp = reward_;
  reward_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PropertyDTO* ChangeNameResponse::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_release:ChangeNameResponse.reward)
  _has_bits_[0] &= ~0x00000001u;
  ::PropertyDTO* temp = reward_;
  reward_ = nullptr;
  return temp;
}
inline ::PropertyDTO* ChangeNameResponse::_internal_mutable_reward() {
  _has_bits_[0] |= 0x00000001u;
  if (reward_ == nullptr) {
    auto* p = CreateMaybeMessage<::PropertyDTO>(GetArenaForAllocation());
    reward_ = p;
  }
  return reward_;
}
inline ::PropertyDTO* ChangeNameResponse::mutable_reward() {
  ::PropertyDTO* _msg = _internal_mutable_reward();
  // @@protoc_insertion_point(field_mutable:ChangeNameResponse.reward)
  return _msg;
}
inline void ChangeNameResponse::set_allocated_reward(::PropertyDTO* reward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reward_);
  }
  if (reward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reward));
    if (message_arena != submessage_arena) {
      reward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:ChangeNameResponse.reward)
}

// -------------------------------------------------------------------

// SetGuideRequest

// required int32 id = 1;
inline bool SetGuideRequest::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetGuideRequest::has_id() const {
  return _internal_has_id();
}
inline void SetGuideRequest::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SetGuideRequest::_internal_id() const {
  return id_;
}
inline int32_t SetGuideRequest::id() const {
  // @@protoc_insertion_point(field_get:SetGuideRequest.id)
  return _internal_id();
}
inline void SetGuideRequest::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void SetGuideRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SetGuideRequest.id)
}

// -------------------------------------------------------------------

// PlayerDataPush

// required .PlayerDTO player = 1;
inline bool PlayerDataPush::_internal_has_player() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || player_ != nullptr);
  return value;
}
inline bool PlayerDataPush::has_player() const {
  return _internal_has_player();
}
inline void PlayerDataPush::clear_player() {
  if (player_ != nullptr) player_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerDTO& PlayerDataPush::_internal_player() const {
  const ::PlayerDTO* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerDTO&>(
      ::_PlayerDTO_default_instance_);
}
inline const ::PlayerDTO& PlayerDataPush::player() const {
  // @@protoc_insertion_point(field_get:PlayerDataPush.player)
  return _internal_player();
}
inline void PlayerDataPush::unsafe_arena_set_allocated_player(
    ::PlayerDTO* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerDataPush.player)
}
inline ::PlayerDTO* PlayerDataPush::release_player() {
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerDTO* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerDTO* PlayerDataPush::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:PlayerDataPush.player)
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerDTO* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::PlayerDTO* PlayerDataPush::_internal_mutable_player() {
  _has_bits_[0] |= 0x00000001u;
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerDTO>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::PlayerDTO* PlayerDataPush::mutable_player() {
  ::PlayerDTO* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:PlayerDataPush.player)
  return _msg;
}
inline void PlayerDataPush::set_allocated_player(::PlayerDTO* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:PlayerDataPush.player)
}

// -------------------------------------------------------------------

// PlayerPropertyChangePush

// repeated .PropertyDTO properties = 1;
inline int PlayerPropertyChangePush::_internal_properties_size() const {
  return properties_.size();
}
inline int PlayerPropertyChangePush::properties_size() const {
  return _internal_properties_size();
}
inline ::PropertyDTO* PlayerPropertyChangePush::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerPropertyChangePush.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >*
PlayerPropertyChangePush::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:PlayerPropertyChangePush.properties)
  return &properties_;
}
inline const ::PropertyDTO& PlayerPropertyChangePush::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::PropertyDTO& PlayerPropertyChangePush::properties(int index) const {
  // @@protoc_insertion_point(field_get:PlayerPropertyChangePush.properties)
  return _internal_properties(index);
}
inline ::PropertyDTO* PlayerPropertyChangePush::_internal_add_properties() {
  return properties_.Add();
}
inline ::PropertyDTO* PlayerPropertyChangePush::add_properties() {
  ::PropertyDTO* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:PlayerPropertyChangePush.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PropertyDTO >&
PlayerPropertyChangePush::properties() const {
  // @@protoc_insertion_point(field_list:PlayerPropertyChangePush.properties)
  return properties_;
}

// -------------------------------------------------------------------

// PlayerLevelUpPush

// required int32 level = 1;
inline bool PlayerLevelUpPush::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerLevelUpPush::has_level() const {
  return _internal_has_level();
}
inline void PlayerLevelUpPush::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t PlayerLevelUpPush::_internal_level() const {
  return level_;
}
inline int32_t PlayerLevelUpPush::level() const {
  // @@protoc_insertion_point(field_get:PlayerLevelUpPush.level)
  return _internal_level();
}
inline void PlayerLevelUpPush::_internal_set_level(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  level_ = value;
}
inline void PlayerLevelUpPush::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:PlayerLevelUpPush.level)
}

// -------------------------------------------------------------------

// PlayerProtectPush

// required int32 bornProtectEndTime = 1;
inline bool PlayerProtectPush::_internal_has_bornprotectendtime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerProtectPush::has_bornprotectendtime() const {
  return _internal_has_bornprotectendtime();
}
inline void PlayerProtectPush::clear_bornprotectendtime() {
  bornprotectendtime_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t PlayerProtectPush::_internal_bornprotectendtime() const {
  return bornprotectendtime_;
}
inline int32_t PlayerProtectPush::bornprotectendtime() const {
  // @@protoc_insertion_point(field_get:PlayerProtectPush.bornProtectEndTime)
  return _internal_bornprotectendtime();
}
inline void PlayerProtectPush::_internal_set_bornprotectendtime(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  bornprotectendtime_ = value;
}
inline void PlayerProtectPush::set_bornprotectendtime(int32_t value) {
  _internal_set_bornprotectendtime(value);
  // @@protoc_insertion_point(field_set:PlayerProtectPush.bornProtectEndTime)
}

// required int32 atkProtectEndTime = 2;
inline bool PlayerProtectPush::_internal_has_atkprotectendtime() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerProtectPush::has_atkprotectendtime() const {
  return _internal_has_atkprotectendtime();
}
inline void PlayerProtectPush::clear_atkprotectendtime() {
  atkprotectendtime_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t PlayerProtectPush::_internal_atkprotectendtime() const {
  return atkprotectendtime_;
}
inline int32_t PlayerProtectPush::atkprotectendtime() const {
  // @@protoc_insertion_point(field_get:PlayerProtectPush.atkProtectEndTime)
  return _internal_atkprotectendtime();
}
inline void PlayerProtectPush::_internal_set_atkprotectendtime(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  atkprotectendtime_ = value;
}
inline void PlayerProtectPush::set_atkprotectendtime(int32_t value) {
  _internal_set_atkprotectendtime(value);
  // @@protoc_insertion_point(field_set:PlayerProtectPush.atkProtectEndTime)
}

// required int32 spyProtectEndTime = 3;
inline bool PlayerProtectPush::_internal_has_spyprotectendtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerProtectPush::has_spyprotectendtime() const {
  return _internal_has_spyprotectendtime();
}
inline void PlayerProtectPush::clear_spyprotectendtime() {
  spyprotectendtime_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t PlayerProtectPush::_internal_spyprotectendtime() const {
  return spyprotectendtime_;
}
inline int32_t PlayerProtectPush::spyprotectendtime() const {
  // @@protoc_insertion_point(field_get:PlayerProtectPush.spyProtectEndTime)
  return _internal_spyprotectendtime();
}
inline void PlayerProtectPush::_internal_set_spyprotectendtime(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  spyprotectendtime_ = value;
}
inline void PlayerProtectPush::set_spyprotectendtime(int32_t value) {
  _internal_set_spyprotectendtime(value);
  // @@protoc_insertion_point(field_set:PlayerProtectPush.spyProtectEndTime)
}

// -------------------------------------------------------------------

// PlayerCount

// required int32 type = 1;
inline bool PlayerCount::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerCount::has_type() const {
  return _internal_has_type();
}
inline void PlayerCount::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t PlayerCount::_internal_type() const {
  return type_;
}
inline int32_t PlayerCount::type() const {
  // @@protoc_insertion_point(field_get:PlayerCount.type)
  return _internal_type();
}
inline void PlayerCount::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void PlayerCount::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PlayerCount.type)
}

// required int32 point = 2;
inline bool PlayerCount::_internal_has_point() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerCount::has_point() const {
  return _internal_has_point();
}
inline void PlayerCount::clear_point() {
  point_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t PlayerCount::_internal_point() const {
  return point_;
}
inline int32_t PlayerCount::point() const {
  // @@protoc_insertion_point(field_get:PlayerCount.point)
  return _internal_point();
}
inline void PlayerCount::_internal_set_point(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  point_ = value;
}
inline void PlayerCount::set_point(int32_t value) {
  _internal_set_point(value);
  // @@protoc_insertion_point(field_set:PlayerCount.point)
}

// required int32 defCount = 3;
inline bool PlayerCount::_internal_has_defcount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerCount::has_defcount() const {
  return _internal_has_defcount();
}
inline void PlayerCount::clear_defcount() {
  defcount_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t PlayerCount::_internal_defcount() const {
  return defcount_;
}
inline int32_t PlayerCount::defcount() const {
  // @@protoc_insertion_point(field_get:PlayerCount.defCount)
  return _internal_defcount();
}
inline void PlayerCount::_internal_set_defcount(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  defcount_ = value;
}
inline void PlayerCount::set_defcount(int32_t value) {
  _internal_set_defcount(value);
  // @@protoc_insertion_point(field_set:PlayerCount.defCount)
}

// optional int32 addCount = 4;
inline bool PlayerCount::_internal_has_addcount() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerCount::has_addcount() const {
  return _internal_has_addcount();
}
inline void PlayerCount::clear_addcount() {
  addcount_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t PlayerCount::_internal_addcount() const {
  return addcount_;
}
inline int32_t PlayerCount::addcount() const {
  // @@protoc_insertion_point(field_get:PlayerCount.addCount)
  return _internal_addcount();
}
inline void PlayerCount::_internal_set_addcount(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  addcount_ = value;
}
inline void PlayerCount::set_addcount(int32_t value) {
  _internal_set_addcount(value);
  // @@protoc_insertion_point(field_set:PlayerCount.addCount)
}

// -------------------------------------------------------------------

// PlayerCountPush

// repeated .PlayerCount counts = 1;
inline int PlayerCountPush::_internal_counts_size() const {
  return counts_.size();
}
inline int PlayerCountPush::counts_size() const {
  return _internal_counts_size();
}
inline void PlayerCountPush::clear_counts() {
  counts_.Clear();
}
inline ::PlayerCount* PlayerCountPush::mutable_counts(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerCountPush.counts)
  return counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerCount >*
PlayerCountPush::mutable_counts() {
  // @@protoc_insertion_point(field_mutable_list:PlayerCountPush.counts)
  return &counts_;
}
inline const ::PlayerCount& PlayerCountPush::_internal_counts(int index) const {
  return counts_.Get(index);
}
inline const ::PlayerCount& PlayerCountPush::counts(int index) const {
  // @@protoc_insertion_point(field_get:PlayerCountPush.counts)
  return _internal_counts(index);
}
inline ::PlayerCount* PlayerCountPush::_internal_add_counts() {
  return counts_.Add();
}
inline ::PlayerCount* PlayerCountPush::add_counts() {
  ::PlayerCount* _add = _internal_add_counts();
  // @@protoc_insertion_point(field_add:PlayerCountPush.counts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerCount >&
PlayerCountPush::counts() const {
  // @@protoc_insertion_point(field_list:PlayerCountPush.counts)
  return counts_;
}

// -------------------------------------------------------------------

// PlayeBattlePush

// required int32 battleValue = 1;
inline bool PlayeBattlePush::_internal_has_battlevalue() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayeBattlePush::has_battlevalue() const {
  return _internal_has_battlevalue();
}
inline void PlayeBattlePush::clear_battlevalue() {
  battlevalue_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t PlayeBattlePush::_internal_battlevalue() const {
  return battlevalue_;
}
inline int32_t PlayeBattlePush::battlevalue() const {
  // @@protoc_insertion_point(field_get:PlayeBattlePush.battleValue)
  return _internal_battlevalue();
}
inline void PlayeBattlePush::_internal_set_battlevalue(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  battlevalue_ = value;
}
inline void PlayeBattlePush::set_battlevalue(int32_t value) {
  _internal_set_battlevalue(value);
  // @@protoc_insertion_point(field_set:PlayeBattlePush.battleValue)
}

// -------------------------------------------------------------------

// TalentPush

// repeated int32 talentIds = 1;
inline int TalentPush::_internal_talentids_size() const {
  return talentids_.size();
}
inline int TalentPush::talentids_size() const {
  return _internal_talentids_size();
}
inline void TalentPush::clear_talentids() {
  talentids_.Clear();
}
inline int32_t TalentPush::_internal_talentids(int index) const {
  return talentids_.Get(index);
}
inline int32_t TalentPush::talentids(int index) const {
  // @@protoc_insertion_point(field_get:TalentPush.talentIds)
  return _internal_talentids(index);
}
inline void TalentPush::set_talentids(int index, int32_t value) {
  talentids_.Set(index, value);
  // @@protoc_insertion_point(field_set:TalentPush.talentIds)
}
inline void TalentPush::_internal_add_talentids(int32_t value) {
  talentids_.Add(value);
}
inline void TalentPush::add_talentids(int32_t value) {
  _internal_add_talentids(value);
  // @@protoc_insertion_point(field_add:TalentPush.talentIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TalentPush::_internal_talentids() const {
  return talentids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TalentPush::talentids() const {
  // @@protoc_insertion_point(field_list:TalentPush.talentIds)
  return _internal_talentids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TalentPush::_internal_mutable_talentids() {
  return &talentids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TalentPush::mutable_talentids() {
  // @@protoc_insertion_point(field_mutable_list:TalentPush.talentIds)
  return _internal_mutable_talentids();
}

// -------------------------------------------------------------------

// VipInfoPush

// required int32 lv = 1;
inline bool VipInfoPush::_internal_has_lv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VipInfoPush::has_lv() const {
  return _internal_has_lv();
}
inline void VipInfoPush::clear_lv() {
  lv_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t VipInfoPush::_internal_lv() const {
  return lv_;
}
inline int32_t VipInfoPush::lv() const {
  // @@protoc_insertion_point(field_get:VipInfoPush.lv)
  return _internal_lv();
}
inline void VipInfoPush::_internal_set_lv(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  lv_ = value;
}
inline void VipInfoPush::set_lv(int32_t value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:VipInfoPush.lv)
}

// required int32 exp = 2;
inline bool VipInfoPush::_internal_has_exp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VipInfoPush::has_exp() const {
  return _internal_has_exp();
}
inline void VipInfoPush::clear_exp() {
  exp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t VipInfoPush::_internal_exp() const {
  return exp_;
}
inline int32_t VipInfoPush::exp() const {
  // @@protoc_insertion_point(field_get:VipInfoPush.exp)
  return _internal_exp();
}
inline void VipInfoPush::_internal_set_exp(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  exp_ = value;
}
inline void VipInfoPush::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:VipInfoPush.exp)
}

// required int32 sign = 3;
inline bool VipInfoPush::_internal_has_sign() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VipInfoPush::has_sign() const {
  return _internal_has_sign();
}
inline void VipInfoPush::clear_sign() {
  sign_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t VipInfoPush::_internal_sign() const {
  return sign_;
}
inline int32_t VipInfoPush::sign() const {
  // @@protoc_insertion_point(field_get:VipInfoPush.sign)
  return _internal_sign();
}
inline void VipInfoPush::_internal_set_sign(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  sign_ = value;
}
inline void VipInfoPush::set_sign(int32_t value) {
  _internal_set_sign(value);
  // @@protoc_insertion_point(field_set:VipInfoPush.sign)
}

// -------------------------------------------------------------------

// VipActiveInfoPush

// required int32 activeEnd = 1;
inline bool VipActiveInfoPush::_internal_has_activeend() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VipActiveInfoPush::has_activeend() const {
  return _internal_has_activeend();
}
inline void VipActiveInfoPush::clear_activeend() {
  activeend_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t VipActiveInfoPush::_internal_activeend() const {
  return activeend_;
}
inline int32_t VipActiveInfoPush::activeend() const {
  // @@protoc_insertion_point(field_get:VipActiveInfoPush.activeEnd)
  return _internal_activeend();
}
inline void VipActiveInfoPush::_internal_set_activeend(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  activeend_ = value;
}
inline void VipActiveInfoPush::set_activeend(int32_t value) {
  _internal_set_activeend(value);
  // @@protoc_insertion_point(field_set:VipActiveInfoPush.activeEnd)
}

// -------------------------------------------------------------------

// SysTimePush

// required int64 currTime = 1;
inline bool SysTimePush::_internal_has_currtime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SysTimePush::has_currtime() const {
  return _internal_has_currtime();
}
inline void SysTimePush::clear_currtime() {
  currtime_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t SysTimePush::_internal_currtime() const {
  return currtime_;
}
inline int64_t SysTimePush::currtime() const {
  // @@protoc_insertion_point(field_get:SysTimePush.currTime)
  return _internal_currtime();
}
inline void SysTimePush::_internal_set_currtime(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  currtime_ = value;
}
inline void SysTimePush::set_currtime(int64_t value) {
  _internal_set_currtime(value);
  // @@protoc_insertion_point(field_set:SysTimePush.currTime)
}

// -------------------------------------------------------------------

// GuidePush

// required .GuideDTO guide = 1;
inline bool GuidePush::_internal_has_guide() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || guide_ != nullptr);
  return value;
}
inline bool GuidePush::has_guide() const {
  return _internal_has_guide();
}
inline void GuidePush::clear_guide() {
  if (guide_ != nullptr) guide_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::GuideDTO& GuidePush::_internal_guide() const {
  const ::GuideDTO* p = guide_;
  return p != nullptr ? *p : reinterpret_cast<const ::GuideDTO&>(
      ::_GuideDTO_default_instance_);
}
inline const ::GuideDTO& GuidePush::guide() const {
  // @@protoc_insertion_point(field_get:GuidePush.guide)
  return _internal_guide();
}
inline void GuidePush::unsafe_arena_set_allocated_guide(
    ::GuideDTO* guide) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(guide_);
  }
  guide_ = guide;
  if (guide) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GuidePush.guide)
}
inline ::GuideDTO* GuidePush::release_guide() {
  _has_bits_[0] &= ~0x00000001u;
  ::GuideDTO* temp = guide_;
  guide_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GuideDTO* GuidePush::unsafe_arena_release_guide() {
  // @@protoc_insertion_point(field_release:GuidePush.guide)
  _has_bits_[0] &= ~0x00000001u;
  ::GuideDTO* temp = guide_;
  guide_ = nullptr;
  return temp;
}
inline ::GuideDTO* GuidePush::_internal_mutable_guide() {
  _has_bits_[0] |= 0x00000001u;
  if (guide_ == nullptr) {
    auto* p = CreateMaybeMessage<::GuideDTO>(GetArenaForAllocation());
    guide_ = p;
  }
  return guide_;
}
inline ::GuideDTO* GuidePush::mutable_guide() {
  ::GuideDTO* _msg = _internal_mutable_guide();
  // @@protoc_insertion_point(field_mutable:GuidePush.guide)
  return _msg;
}
inline void GuidePush::set_allocated_guide(::GuideDTO* guide) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete guide_;
  }
  if (guide) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guide);
    if (message_arena != submessage_arena) {
      guide = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guide, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guide_ = guide;
  // @@protoc_insertion_point(field_set_allocated:GuidePush.guide)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PlayerCommandId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PlayerCommandId>() {
  return ::PlayerCommandId_descriptor();
}
template <> struct is_proto_enum< ::ReconnectState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReconnectState>() {
  return ::ReconnectState_descriptor();
}
template <> struct is_proto_enum< ::PlayerPushId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PlayerPushId>() {
  return ::PlayerPushId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_player_2eproto
