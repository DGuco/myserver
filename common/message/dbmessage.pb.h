// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbmessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dbmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dbmessage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dbmessage_2eproto;
class CMsgExecuteSqlRequest;
struct CMsgExecuteSqlRequestDefaultTypeInternal;
extern CMsgExecuteSqlRequestDefaultTypeInternal _CMsgExecuteSqlRequest_default_instance_;
class CMsgExecuteSqlResponse;
struct CMsgExecuteSqlResponseDefaultTypeInternal;
extern CMsgExecuteSqlResponseDefaultTypeInternal _CMsgExecuteSqlResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgExecuteSqlRequest* Arena::CreateMaybeMessage<::CMsgExecuteSqlRequest>(Arena*);
template<> ::CMsgExecuteSqlResponse* Arena::CreateMaybeMessage<::CMsgExecuteSqlResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgExecuteSqlRequest_Msg : int {
  CMsgExecuteSqlRequest_Msg_MsgID = 10001
};
bool CMsgExecuteSqlRequest_Msg_IsValid(int value);
constexpr CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MIN = CMsgExecuteSqlRequest_Msg_MsgID;
constexpr CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MAX = CMsgExecuteSqlRequest_Msg_MsgID;
constexpr int CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlRequest_Msg_Msg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgExecuteSqlRequest_Msg_descriptor();
template<typename T>
inline const std::string& CMsgExecuteSqlRequest_Msg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgExecuteSqlRequest_Msg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgExecuteSqlRequest_Msg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgExecuteSqlRequest_Msg_descriptor(), enum_t_value);
}
inline bool CMsgExecuteSqlRequest_Msg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgExecuteSqlRequest_Msg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgExecuteSqlRequest_Msg>(
    CMsgExecuteSqlRequest_Msg_descriptor(), name, value);
}
enum CMsgExecuteSqlResponse_Msg : int {
  CMsgExecuteSqlResponse_Msg_MsgID = 10002
};
bool CMsgExecuteSqlResponse_Msg_IsValid(int value);
constexpr CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MIN = CMsgExecuteSqlResponse_Msg_MsgID;
constexpr CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MAX = CMsgExecuteSqlResponse_Msg_MsgID;
constexpr int CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlResponse_Msg_Msg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgExecuteSqlResponse_Msg_descriptor();
template<typename T>
inline const std::string& CMsgExecuteSqlResponse_Msg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgExecuteSqlResponse_Msg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgExecuteSqlResponse_Msg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgExecuteSqlResponse_Msg_descriptor(), enum_t_value);
}
inline bool CMsgExecuteSqlResponse_Msg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgExecuteSqlResponse_Msg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgExecuteSqlResponse_Msg>(
    CMsgExecuteSqlResponse_Msg_descriptor(), name, value);
}
enum SQLTYPE : int {
  SELECT = 1,
  INSERT = 2,
  UPDATE = 3,
  DELETE = 4,
  CALL = 5
};
bool SQLTYPE_IsValid(int value);
constexpr SQLTYPE SQLTYPE_MIN = SELECT;
constexpr SQLTYPE SQLTYPE_MAX = CALL;
constexpr int SQLTYPE_ARRAYSIZE = SQLTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SQLTYPE_descriptor();
template<typename T>
inline const std::string& SQLTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SQLTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SQLTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SQLTYPE_descriptor(), enum_t_value);
}
inline bool SQLTYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SQLTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SQLTYPE>(
    SQLTYPE_descriptor(), name, value);
}
enum CALLBACK : int {
  MUSTCALLBACK = 1,
  NOTCALLBACK = 2
};
bool CALLBACK_IsValid(int value);
constexpr CALLBACK CALLBACK_MIN = MUSTCALLBACK;
constexpr CALLBACK CALLBACK_MAX = NOTCALLBACK;
constexpr int CALLBACK_ARRAYSIZE = CALLBACK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CALLBACK_descriptor();
template<typename T>
inline const std::string& CALLBACK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CALLBACK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CALLBACK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CALLBACK_descriptor(), enum_t_value);
}
inline bool CALLBACK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CALLBACK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CALLBACK>(
    CALLBACK_descriptor(), name, value);
}
enum BLOB : int {
  HASBLOB = 1,
  NONEBLOB = 2
};
bool BLOB_IsValid(int value);
constexpr BLOB BLOB_MIN = HASBLOB;
constexpr BLOB BLOB_MAX = NONEBLOB;
constexpr int BLOB_ARRAYSIZE = BLOB_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BLOB_descriptor();
template<typename T>
inline const std::string& BLOB_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BLOB>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BLOB_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BLOB_descriptor(), enum_t_value);
}
inline bool BLOB_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BLOB* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BLOB>(
    BLOB_descriptor(), name, value);
}
// ===================================================================

class CMsgExecuteSqlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgExecuteSqlRequest) */ {
 public:
  inline CMsgExecuteSqlRequest() : CMsgExecuteSqlRequest(nullptr) {}
  ~CMsgExecuteSqlRequest() override;
  explicit PROTOBUF_CONSTEXPR CMsgExecuteSqlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgExecuteSqlRequest(const CMsgExecuteSqlRequest& from);
  CMsgExecuteSqlRequest(CMsgExecuteSqlRequest&& from) noexcept
    : CMsgExecuteSqlRequest() {
    *this = ::std::move(from);
  }

  inline CMsgExecuteSqlRequest& operator=(const CMsgExecuteSqlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgExecuteSqlRequest& operator=(CMsgExecuteSqlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgExecuteSqlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgExecuteSqlRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgExecuteSqlRequest*>(
               &_CMsgExecuteSqlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgExecuteSqlRequest& a, CMsgExecuteSqlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgExecuteSqlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgExecuteSqlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgExecuteSqlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgExecuteSqlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgExecuteSqlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgExecuteSqlRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgExecuteSqlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgExecuteSqlRequest";
  }
  protected:
  explicit CMsgExecuteSqlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlRequest_Msg Msg;
  static constexpr Msg MsgID =
    CMsgExecuteSqlRequest_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlRequest_Msg_IsValid(value);
  }
  static constexpr Msg Msg_MIN =
    CMsgExecuteSqlRequest_Msg_Msg_MIN;
  static constexpr Msg Msg_MAX =
    CMsgExecuteSqlRequest_Msg_Msg_MAX;
  static constexpr int Msg_ARRAYSIZE =
    CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlRequest_Msg_descriptor();
  }
  template<typename T>
  static inline const std::string& Msg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Msg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Msg_Name.");
    return CMsgExecuteSqlRequest_Msg_Name(enum_t_value);
  }
  static inline bool Msg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Msg* value) {
    return CMsgExecuteSqlRequest_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSqlFieldNumber = 7,
    kBufferFieldNumber = 9,
    kSQLWhereFieldNumber = 10,
    kLogicTypeFieldNumber = 1,
    kSessionIDFieldNumber = 2,
    kTimeStampFieldNumber = 3,
    kTeamIDFieldNumber = 4,
    kBufSizeFieldNumber = 8,
    kOutNumberFieldNumber = 11,
    kHasBlobFieldNumber = 12,
    kSqlTypeFieldNumber = 5,
    kCallbackFieldNumber = 6,
  };
  // optional string Sql = 7;
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // optional bytes Buffer = 9;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // optional string SQLWhere = 10;
  bool has_sqlwhere() const;
  private:
  bool _internal_has_sqlwhere() const;
  public:
  void clear_sqlwhere();
  const std::string& sqlwhere() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sqlwhere(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sqlwhere();
  PROTOBUF_NODISCARD std::string* release_sqlwhere();
  void set_allocated_sqlwhere(std::string* sqlwhere);
  private:
  const std::string& _internal_sqlwhere() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sqlwhere(const std::string& value);
  std::string* _internal_mutable_sqlwhere();
  public:

  // optional uint32 LogicType = 1;
  bool has_logictype() const;
  private:
  bool _internal_has_logictype() const;
  public:
  void clear_logictype();
  uint32_t logictype() const;
  void set_logictype(uint32_t value);
  private:
  uint32_t _internal_logictype() const;
  void _internal_set_logictype(uint32_t value);
  public:

  // optional uint32 SessionID = 2 [default = 0];
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  uint32_t sessionid() const;
  void set_sessionid(uint32_t value);
  private:
  uint32_t _internal_sessionid() const;
  void _internal_set_sessionid(uint32_t value);
  public:

  // optional uint64 TimeStamp = 3 [default = 0];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional uint64 TeamID = 4 [default = 0];
  bool has_teamid() const;
  private:
  bool _internal_has_teamid() const;
  public:
  void clear_teamid();
  uint64_t teamid() const;
  void set_teamid(uint64_t value);
  private:
  uint64_t _internal_teamid() const;
  void _internal_set_teamid(uint64_t value);
  public:

  // optional uint32 BufSize = 8 [default = 0];
  bool has_bufsize() const;
  private:
  bool _internal_has_bufsize() const;
  public:
  void clear_bufsize();
  uint32_t bufsize() const;
  void set_bufsize(uint32_t value);
  private:
  uint32_t _internal_bufsize() const;
  void _internal_set_bufsize(uint32_t value);
  public:

  // optional uint32 OutNumber = 11 [default = 0];
  bool has_outnumber() const;
  private:
  bool _internal_has_outnumber() const;
  public:
  void clear_outnumber();
  uint32_t outnumber() const;
  void set_outnumber(uint32_t value);
  private:
  uint32_t _internal_outnumber() const;
  void _internal_set_outnumber(uint32_t value);
  public:

  // optional .BLOB HasBlob = 12;
  bool has_hasblob() const;
  private:
  bool _internal_has_hasblob() const;
  public:
  void clear_hasblob();
  ::BLOB hasblob() const;
  void set_hasblob(::BLOB value);
  private:
  ::BLOB _internal_hasblob() const;
  void _internal_set_hasblob(::BLOB value);
  public:

  // optional .SQLTYPE SqlType = 5 [default = SELECT];
  bool has_sqltype() const;
  private:
  bool _internal_has_sqltype() const;
  public:
  void clear_sqltype();
  ::SQLTYPE sqltype() const;
  void set_sqltype(::SQLTYPE value);
  private:
  ::SQLTYPE _internal_sqltype() const;
  void _internal_set_sqltype(::SQLTYPE value);
  public:

  // optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
  bool has_callback() const;
  private:
  bool _internal_has_callback() const;
  public:
  void clear_callback();
  ::CALLBACK callback() const;
  void set_callback(::CALLBACK value);
  private:
  ::CALLBACK _internal_callback() const;
  void _internal_set_callback(::CALLBACK value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sqlwhere_;
  uint32_t logictype_;
  uint32_t sessionid_;
  uint64_t timestamp_;
  uint64_t teamid_;
  uint32_t bufsize_;
  uint32_t outnumber_;
  int hasblob_;
  int sqltype_;
  int callback_;
  friend struct ::TableStruct_dbmessage_2eproto;
};
// -------------------------------------------------------------------

class CMsgExecuteSqlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgExecuteSqlResponse) */ {
 public:
  inline CMsgExecuteSqlResponse() : CMsgExecuteSqlResponse(nullptr) {}
  ~CMsgExecuteSqlResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgExecuteSqlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgExecuteSqlResponse(const CMsgExecuteSqlResponse& from);
  CMsgExecuteSqlResponse(CMsgExecuteSqlResponse&& from) noexcept
    : CMsgExecuteSqlResponse() {
    *this = ::std::move(from);
  }

  inline CMsgExecuteSqlResponse& operator=(const CMsgExecuteSqlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgExecuteSqlResponse& operator=(CMsgExecuteSqlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgExecuteSqlResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgExecuteSqlResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgExecuteSqlResponse*>(
               &_CMsgExecuteSqlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgExecuteSqlResponse& a, CMsgExecuteSqlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgExecuteSqlResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgExecuteSqlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgExecuteSqlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgExecuteSqlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgExecuteSqlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgExecuteSqlResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgExecuteSqlResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgExecuteSqlResponse";
  }
  protected:
  explicit CMsgExecuteSqlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlResponse_Msg Msg;
  static constexpr Msg MsgID =
    CMsgExecuteSqlResponse_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlResponse_Msg_IsValid(value);
  }
  static constexpr Msg Msg_MIN =
    CMsgExecuteSqlResponse_Msg_Msg_MIN;
  static constexpr Msg Msg_MAX =
    CMsgExecuteSqlResponse_Msg_Msg_MAX;
  static constexpr int Msg_ARRAYSIZE =
    CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlResponse_Msg_descriptor();
  }
  template<typename T>
  static inline const std::string& Msg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Msg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Msg_Name.");
    return CMsgExecuteSqlResponse_Msg_Name(enum_t_value);
  }
  static inline bool Msg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Msg* value) {
    return CMsgExecuteSqlResponse_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFieldValueFieldNumber = 8,
    kFieldValueLenFieldNumber = 9,
    kLogicTypeFieldNumber = 1,
    kSessionIDFieldNumber = 2,
    kTimeStampFieldNumber = 3,
    kTeamIDFieldNumber = 4,
    kResultCodeFieldNumber = 5,
    kRowCountFieldNumber = 6,
    kColCountFieldNumber = 7,
  };
  // repeated bytes FieldValue = 8;
  int fieldvalue_size() const;
  private:
  int _internal_fieldvalue_size() const;
  public:
  void clear_fieldvalue();
  const std::string& fieldvalue(int index) const;
  std::string* mutable_fieldvalue(int index);
  void set_fieldvalue(int index, const std::string& value);
  void set_fieldvalue(int index, std::string&& value);
  void set_fieldvalue(int index, const char* value);
  void set_fieldvalue(int index, const void* value, size_t size);
  std::string* add_fieldvalue();
  void add_fieldvalue(const std::string& value);
  void add_fieldvalue(std::string&& value);
  void add_fieldvalue(const char* value);
  void add_fieldvalue(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fieldvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fieldvalue();
  private:
  const std::string& _internal_fieldvalue(int index) const;
  std::string* _internal_add_fieldvalue();
  public:

  // repeated uint32 FieldValueLen = 9;
  int fieldvaluelen_size() const;
  private:
  int _internal_fieldvaluelen_size() const;
  public:
  void clear_fieldvaluelen();
  private:
  uint32_t _internal_fieldvaluelen(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_fieldvaluelen() const;
  void _internal_add_fieldvaluelen(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_fieldvaluelen();
  public:
  uint32_t fieldvaluelen(int index) const;
  void set_fieldvaluelen(int index, uint32_t value);
  void add_fieldvaluelen(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      fieldvaluelen() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_fieldvaluelen();

  // optional uint32 LogicType = 1;
  bool has_logictype() const;
  private:
  bool _internal_has_logictype() const;
  public:
  void clear_logictype();
  uint32_t logictype() const;
  void set_logictype(uint32_t value);
  private:
  uint32_t _internal_logictype() const;
  void _internal_set_logictype(uint32_t value);
  public:

  // optional uint32 SessionID = 2;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  uint32_t sessionid() const;
  void set_sessionid(uint32_t value);
  private:
  uint32_t _internal_sessionid() const;
  void _internal_set_sessionid(uint32_t value);
  public:

  // optional uint64 TimeStamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional uint64 TeamID = 4;
  bool has_teamid() const;
  private:
  bool _internal_has_teamid() const;
  public:
  void clear_teamid();
  uint64_t teamid() const;
  void set_teamid(uint64_t value);
  private:
  uint64_t _internal_teamid() const;
  void _internal_set_teamid(uint64_t value);
  public:

  // optional uint32 ResultCode = 5;
  bool has_resultcode() const;
  private:
  bool _internal_has_resultcode() const;
  public:
  void clear_resultcode();
  uint32_t resultcode() const;
  void set_resultcode(uint32_t value);
  private:
  uint32_t _internal_resultcode() const;
  void _internal_set_resultcode(uint32_t value);
  public:

  // optional uint32 RowCount = 6 [default = 0];
  bool has_rowcount() const;
  private:
  bool _internal_has_rowcount() const;
  public:
  void clear_rowcount();
  uint32_t rowcount() const;
  void set_rowcount(uint32_t value);
  private:
  uint32_t _internal_rowcount() const;
  void _internal_set_rowcount(uint32_t value);
  public:

  // optional uint32 ColCount = 7 [default = 0];
  bool has_colcount() const;
  private:
  bool _internal_has_colcount() const;
  public:
  void clear_colcount();
  uint32_t colcount() const;
  void set_colcount(uint32_t value);
  private:
  uint32_t _internal_colcount() const;
  void _internal_set_colcount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fieldvalue_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > fieldvaluelen_;
  uint32_t logictype_;
  uint32_t sessionid_;
  uint64_t timestamp_;
  uint64_t teamid_;
  uint32_t resultcode_;
  uint32_t rowcount_;
  uint32_t colcount_;
  friend struct ::TableStruct_dbmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgExecuteSqlRequest

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlRequest::_internal_has_logictype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_logictype() const {
  return _internal_has_logictype();
}
inline void CMsgExecuteSqlRequest::clear_logictype() {
  logictype_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgExecuteSqlRequest::_internal_logictype() const {
  return logictype_;
}
inline uint32_t CMsgExecuteSqlRequest::logictype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.LogicType)
  return _internal_logictype();
}
inline void CMsgExecuteSqlRequest::_internal_set_logictype(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  logictype_ = value;
}
inline void CMsgExecuteSqlRequest::set_logictype(uint32_t value) {
  _internal_set_logictype(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.LogicType)
}

// optional uint32 SessionID = 2 [default = 0];
inline bool CMsgExecuteSqlRequest::_internal_has_sessionid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void CMsgExecuteSqlRequest::clear_sessionid() {
  sessionid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgExecuteSqlRequest::_internal_sessionid() const {
  return sessionid_;
}
inline uint32_t CMsgExecuteSqlRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SessionID)
  return _internal_sessionid();
}
inline void CMsgExecuteSqlRequest::_internal_set_sessionid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  sessionid_ = value;
}
inline void CMsgExecuteSqlRequest::set_sessionid(uint32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SessionID)
}

// optional uint64 TimeStamp = 3 [default = 0];
inline bool CMsgExecuteSqlRequest::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgExecuteSqlRequest::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CMsgExecuteSqlRequest::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t CMsgExecuteSqlRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.TimeStamp)
  return _internal_timestamp();
}
inline void CMsgExecuteSqlRequest::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = value;
}
inline void CMsgExecuteSqlRequest::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.TimeStamp)
}

// optional uint64 TeamID = 4 [default = 0];
inline bool CMsgExecuteSqlRequest::_internal_has_teamid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_teamid() const {
  return _internal_has_teamid();
}
inline void CMsgExecuteSqlRequest::clear_teamid() {
  teamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgExecuteSqlRequest::_internal_teamid() const {
  return teamid_;
}
inline uint64_t CMsgExecuteSqlRequest::teamid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.TeamID)
  return _internal_teamid();
}
inline void CMsgExecuteSqlRequest::_internal_set_teamid(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  teamid_ = value;
}
inline void CMsgExecuteSqlRequest::set_teamid(uint64_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.TeamID)
}

// optional .SQLTYPE SqlType = 5 [default = SELECT];
inline bool CMsgExecuteSqlRequest::_internal_has_sqltype() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_sqltype() const {
  return _internal_has_sqltype();
}
inline void CMsgExecuteSqlRequest::clear_sqltype() {
  sqltype_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::SQLTYPE CMsgExecuteSqlRequest::_internal_sqltype() const {
  return static_cast< ::SQLTYPE >(sqltype_);
}
inline ::SQLTYPE CMsgExecuteSqlRequest::sqltype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SqlType)
  return _internal_sqltype();
}
inline void CMsgExecuteSqlRequest::_internal_set_sqltype(::SQLTYPE value) {
  assert(::SQLTYPE_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  sqltype_ = value;
}
inline void CMsgExecuteSqlRequest::set_sqltype(::SQLTYPE value) {
  _internal_set_sqltype(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SqlType)
}

// optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
inline bool CMsgExecuteSqlRequest::_internal_has_callback() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_callback() const {
  return _internal_has_callback();
}
inline void CMsgExecuteSqlRequest::clear_callback() {
  callback_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::CALLBACK CMsgExecuteSqlRequest::_internal_callback() const {
  return static_cast< ::CALLBACK >(callback_);
}
inline ::CALLBACK CMsgExecuteSqlRequest::callback() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Callback)
  return _internal_callback();
}
inline void CMsgExecuteSqlRequest::_internal_set_callback(::CALLBACK value) {
  assert(::CALLBACK_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  callback_ = value;
}
inline void CMsgExecuteSqlRequest::set_callback(::CALLBACK value) {
  _internal_set_callback(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Callback)
}

// optional string Sql = 7;
inline bool CMsgExecuteSqlRequest::_internal_has_sql() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_sql() const {
  return _internal_has_sql();
}
inline void CMsgExecuteSqlRequest::clear_sql() {
  sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgExecuteSqlRequest::sql() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgExecuteSqlRequest::set_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Sql)
}
inline std::string* CMsgExecuteSqlRequest::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.Sql)
  return _s;
}
inline const std::string& CMsgExecuteSqlRequest::_internal_sql() const {
  return sql_.Get();
}
inline void CMsgExecuteSqlRequest::_internal_set_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sql_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::_internal_mutable_sql() {
  _has_bits_[0] |= 0x00000001u;
  return sql_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::release_sql() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.Sql)
  if (!_internal_has_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sql_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sql_.IsDefault()) {
    sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgExecuteSqlRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sql_.IsDefault()) {
    sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.Sql)
}

// optional uint32 BufSize = 8 [default = 0];
inline bool CMsgExecuteSqlRequest::_internal_has_bufsize() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_bufsize() const {
  return _internal_has_bufsize();
}
inline void CMsgExecuteSqlRequest::clear_bufsize() {
  bufsize_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgExecuteSqlRequest::_internal_bufsize() const {
  return bufsize_;
}
inline uint32_t CMsgExecuteSqlRequest::bufsize() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.BufSize)
  return _internal_bufsize();
}
inline void CMsgExecuteSqlRequest::_internal_set_bufsize(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  bufsize_ = value;
}
inline void CMsgExecuteSqlRequest::set_bufsize(uint32_t value) {
  _internal_set_bufsize(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.BufSize)
}

// optional bytes Buffer = 9;
inline bool CMsgExecuteSqlRequest::_internal_has_buffer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void CMsgExecuteSqlRequest::clear_buffer() {
  buffer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgExecuteSqlRequest::buffer() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgExecuteSqlRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Buffer)
}
inline std::string* CMsgExecuteSqlRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.Buffer)
  return _s;
}
inline const std::string& CMsgExecuteSqlRequest::_internal_buffer() const {
  return buffer_.Get();
}
inline void CMsgExecuteSqlRequest::_internal_set_buffer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::_internal_mutable_buffer() {
  _has_bits_[0] |= 0x00000002u;
  return buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.Buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = buffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault()) {
    buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgExecuteSqlRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  buffer_.SetAllocated(buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault()) {
    buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.Buffer)
}

// optional string SQLWhere = 10;
inline bool CMsgExecuteSqlRequest::_internal_has_sqlwhere() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_sqlwhere() const {
  return _internal_has_sqlwhere();
}
inline void CMsgExecuteSqlRequest::clear_sqlwhere() {
  sqlwhere_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgExecuteSqlRequest::sqlwhere() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SQLWhere)
  return _internal_sqlwhere();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgExecuteSqlRequest::set_sqlwhere(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sqlwhere_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SQLWhere)
}
inline std::string* CMsgExecuteSqlRequest::mutable_sqlwhere() {
  std::string* _s = _internal_mutable_sqlwhere();
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.SQLWhere)
  return _s;
}
inline const std::string& CMsgExecuteSqlRequest::_internal_sqlwhere() const {
  return sqlwhere_.Get();
}
inline void CMsgExecuteSqlRequest::_internal_set_sqlwhere(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sqlwhere_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::_internal_mutable_sqlwhere() {
  _has_bits_[0] |= 0x00000004u;
  return sqlwhere_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgExecuteSqlRequest::release_sqlwhere() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.SQLWhere)
  if (!_internal_has_sqlwhere()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = sqlwhere_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sqlwhere_.IsDefault()) {
    sqlwhere_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgExecuteSqlRequest::set_allocated_sqlwhere(std::string* sqlwhere) {
  if (sqlwhere != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sqlwhere_.SetAllocated(sqlwhere, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sqlwhere_.IsDefault()) {
    sqlwhere_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.SQLWhere)
}

// optional uint32 OutNumber = 11 [default = 0];
inline bool CMsgExecuteSqlRequest::_internal_has_outnumber() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_outnumber() const {
  return _internal_has_outnumber();
}
inline void CMsgExecuteSqlRequest::clear_outnumber() {
  outnumber_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgExecuteSqlRequest::_internal_outnumber() const {
  return outnumber_;
}
inline uint32_t CMsgExecuteSqlRequest::outnumber() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.OutNumber)
  return _internal_outnumber();
}
inline void CMsgExecuteSqlRequest::_internal_set_outnumber(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  outnumber_ = value;
}
inline void CMsgExecuteSqlRequest::set_outnumber(uint32_t value) {
  _internal_set_outnumber(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.OutNumber)
}

// optional .BLOB HasBlob = 12;
inline bool CMsgExecuteSqlRequest::_internal_has_hasblob() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgExecuteSqlRequest::has_hasblob() const {
  return _internal_has_hasblob();
}
inline void CMsgExecuteSqlRequest::clear_hasblob() {
  hasblob_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::BLOB CMsgExecuteSqlRequest::_internal_hasblob() const {
  return static_cast< ::BLOB >(hasblob_);
}
inline ::BLOB CMsgExecuteSqlRequest::hasblob() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.HasBlob)
  return _internal_hasblob();
}
inline void CMsgExecuteSqlRequest::_internal_set_hasblob(::BLOB value) {
  assert(::BLOB_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  hasblob_ = value;
}
inline void CMsgExecuteSqlRequest::set_hasblob(::BLOB value) {
  _internal_set_hasblob(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.HasBlob)
}

// -------------------------------------------------------------------

// CMsgExecuteSqlResponse

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlResponse::_internal_has_logictype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_logictype() const {
  return _internal_has_logictype();
}
inline void CMsgExecuteSqlResponse::clear_logictype() {
  logictype_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgExecuteSqlResponse::_internal_logictype() const {
  return logictype_;
}
inline uint32_t CMsgExecuteSqlResponse::logictype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.LogicType)
  return _internal_logictype();
}
inline void CMsgExecuteSqlResponse::_internal_set_logictype(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  logictype_ = value;
}
inline void CMsgExecuteSqlResponse::set_logictype(uint32_t value) {
  _internal_set_logictype(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.LogicType)
}

// optional uint32 SessionID = 2;
inline bool CMsgExecuteSqlResponse::_internal_has_sessionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void CMsgExecuteSqlResponse::clear_sessionid() {
  sessionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgExecuteSqlResponse::_internal_sessionid() const {
  return sessionid_;
}
inline uint32_t CMsgExecuteSqlResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.SessionID)
  return _internal_sessionid();
}
inline void CMsgExecuteSqlResponse::_internal_set_sessionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  sessionid_ = value;
}
inline void CMsgExecuteSqlResponse::set_sessionid(uint32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.SessionID)
}

// optional uint64 TimeStamp = 3;
inline bool CMsgExecuteSqlResponse::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgExecuteSqlResponse::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgExecuteSqlResponse::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t CMsgExecuteSqlResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.TimeStamp)
  return _internal_timestamp();
}
inline void CMsgExecuteSqlResponse::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
}
inline void CMsgExecuteSqlResponse::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.TimeStamp)
}

// optional uint64 TeamID = 4;
inline bool CMsgExecuteSqlResponse::_internal_has_teamid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_teamid() const {
  return _internal_has_teamid();
}
inline void CMsgExecuteSqlResponse::clear_teamid() {
  teamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CMsgExecuteSqlResponse::_internal_teamid() const {
  return teamid_;
}
inline uint64_t CMsgExecuteSqlResponse::teamid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.TeamID)
  return _internal_teamid();
}
inline void CMsgExecuteSqlResponse::_internal_set_teamid(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  teamid_ = value;
}
inline void CMsgExecuteSqlResponse::set_teamid(uint64_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.TeamID)
}

// optional uint32 ResultCode = 5;
inline bool CMsgExecuteSqlResponse::_internal_has_resultcode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_resultcode() const {
  return _internal_has_resultcode();
}
inline void CMsgExecuteSqlResponse::clear_resultcode() {
  resultcode_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgExecuteSqlResponse::_internal_resultcode() const {
  return resultcode_;
}
inline uint32_t CMsgExecuteSqlResponse::resultcode() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.ResultCode)
  return _internal_resultcode();
}
inline void CMsgExecuteSqlResponse::_internal_set_resultcode(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  resultcode_ = value;
}
inline void CMsgExecuteSqlResponse::set_resultcode(uint32_t value) {
  _internal_set_resultcode(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.ResultCode)
}

// optional uint32 RowCount = 6 [default = 0];
inline bool CMsgExecuteSqlResponse::_internal_has_rowcount() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_rowcount() const {
  return _internal_has_rowcount();
}
inline void CMsgExecuteSqlResponse::clear_rowcount() {
  rowcount_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgExecuteSqlResponse::_internal_rowcount() const {
  return rowcount_;
}
inline uint32_t CMsgExecuteSqlResponse::rowcount() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.RowCount)
  return _internal_rowcount();
}
inline void CMsgExecuteSqlResponse::_internal_set_rowcount(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  rowcount_ = value;
}
inline void CMsgExecuteSqlResponse::set_rowcount(uint32_t value) {
  _internal_set_rowcount(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.RowCount)
}

// optional uint32 ColCount = 7 [default = 0];
inline bool CMsgExecuteSqlResponse::_internal_has_colcount() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgExecuteSqlResponse::has_colcount() const {
  return _internal_has_colcount();
}
inline void CMsgExecuteSqlResponse::clear_colcount() {
  colcount_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgExecuteSqlResponse::_internal_colcount() const {
  return colcount_;
}
inline uint32_t CMsgExecuteSqlResponse::colcount() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.ColCount)
  return _internal_colcount();
}
inline void CMsgExecuteSqlResponse::_internal_set_colcount(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  colcount_ = value;
}
inline void CMsgExecuteSqlResponse::set_colcount(uint32_t value) {
  _internal_set_colcount(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.ColCount)
}

// repeated bytes FieldValue = 8;
inline int CMsgExecuteSqlResponse::_internal_fieldvalue_size() const {
  return fieldvalue_.size();
}
inline int CMsgExecuteSqlResponse::fieldvalue_size() const {
  return _internal_fieldvalue_size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvalue() {
  fieldvalue_.Clear();
}
inline std::string* CMsgExecuteSqlResponse::add_fieldvalue() {
  std::string* _s = _internal_add_fieldvalue();
  // @@protoc_insertion_point(field_add_mutable:CMsgExecuteSqlResponse.FieldValue)
  return _s;
}
inline const std::string& CMsgExecuteSqlResponse::_internal_fieldvalue(int index) const {
  return fieldvalue_.Get(index);
}
inline const std::string& CMsgExecuteSqlResponse::fieldvalue(int index) const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.FieldValue)
  return _internal_fieldvalue(index);
}
inline std::string* CMsgExecuteSqlResponse::mutable_fieldvalue(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_.Mutable(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const std::string& value) {
  fieldvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, std::string&& value) {
  fieldvalue_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fieldvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const void* value, size_t size) {
  fieldvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgExecuteSqlResponse.FieldValue)
}
inline std::string* CMsgExecuteSqlResponse::_internal_add_fieldvalue() {
  return fieldvalue_.Add();
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const std::string& value) {
  fieldvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(std::string&& value) {
  fieldvalue_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fieldvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const void* value, size_t size) {
  fieldvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CMsgExecuteSqlResponse.FieldValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CMsgExecuteSqlResponse::fieldvalue() const {
  // @@protoc_insertion_point(field_list:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CMsgExecuteSqlResponse::mutable_fieldvalue() {
  // @@protoc_insertion_point(field_mutable_list:CMsgExecuteSqlResponse.FieldValue)
  return &fieldvalue_;
}

// repeated uint32 FieldValueLen = 9;
inline int CMsgExecuteSqlResponse::_internal_fieldvaluelen_size() const {
  return fieldvaluelen_.size();
}
inline int CMsgExecuteSqlResponse::fieldvaluelen_size() const {
  return _internal_fieldvaluelen_size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvaluelen() {
  fieldvaluelen_.Clear();
}
inline uint32_t CMsgExecuteSqlResponse::_internal_fieldvaluelen(int index) const {
  return fieldvaluelen_.Get(index);
}
inline uint32_t CMsgExecuteSqlResponse::fieldvaluelen(int index) const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.FieldValueLen)
  return _internal_fieldvaluelen(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvaluelen(int index, uint32_t value) {
  fieldvaluelen_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValueLen)
}
inline void CMsgExecuteSqlResponse::_internal_add_fieldvaluelen(uint32_t value) {
  fieldvaluelen_.Add(value);
}
inline void CMsgExecuteSqlResponse::add_fieldvaluelen(uint32_t value) {
  _internal_add_fieldvaluelen(value);
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValueLen)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgExecuteSqlResponse::_internal_fieldvaluelen() const {
  return fieldvaluelen_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgExecuteSqlResponse::fieldvaluelen() const {
  // @@protoc_insertion_point(field_list:CMsgExecuteSqlResponse.FieldValueLen)
  return _internal_fieldvaluelen();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgExecuteSqlResponse::_internal_mutable_fieldvaluelen() {
  return &fieldvaluelen_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgExecuteSqlResponse::mutable_fieldvaluelen() {
  // @@protoc_insertion_point(field_mutable_list:CMsgExecuteSqlResponse.FieldValueLen)
  return _internal_mutable_fieldvaluelen();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgExecuteSqlRequest_Msg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlRequest_Msg>() {
  return ::CMsgExecuteSqlRequest_Msg_descriptor();
}
template <> struct is_proto_enum< ::CMsgExecuteSqlResponse_Msg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlResponse_Msg>() {
  return ::CMsgExecuteSqlResponse_Msg_descriptor();
}
template <> struct is_proto_enum< ::SQLTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SQLTYPE>() {
  return ::SQLTYPE_descriptor();
}
template <> struct is_proto_enum< ::CALLBACK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CALLBACK>() {
  return ::CALLBACK_descriptor();
}
template <> struct is_proto_enum< ::BLOB> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BLOB>() {
  return ::BLOB_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto
