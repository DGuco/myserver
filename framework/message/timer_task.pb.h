// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timer_task.proto

#ifndef PROTOBUF_timer_5ftask_2eproto__INCLUDED
#define PROTOBUF_timer_5ftask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace slg {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_timer_5ftask_2eproto();
void protobuf_AssignDesc_timer_5ftask_2eproto();
void protobuf_ShutdownFile_timer_5ftask_2eproto();

class TimerTaskTargetDTO;
class TimerTaskDTO;
class TimerTaskCompleteRequest;
class TimerTaskCompleteResponse;
class TimerTaskSpeedUpRequest;
class TimerTaskSpeedUpResponse;
class TimerTaskCancelRequest;
class TimerTaskCancelResponse;
class TimerTaskListPush;
class TimerTaskCompletePush;
class TimerTaskAdjustPush;

enum TimerTaskTargetType {
  TIMER_TARGET_BUILDING = 1,
  TIMER_TARGET_TECH = 2,
  TIMER_TARGET_TRAIN = 3,
  TIMER_SKILL_UPGRADE = 4
};
bool TimerTaskTargetType_IsValid(int value);
const TimerTaskTargetType TimerTaskTargetType_MIN = TIMER_TARGET_BUILDING;
const TimerTaskTargetType TimerTaskTargetType_MAX = TIMER_SKILL_UPGRADE;
const int TimerTaskTargetType_ARRAYSIZE = TimerTaskTargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimerTaskTargetType_descriptor();
inline const ::std::string& TimerTaskTargetType_Name(TimerTaskTargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimerTaskTargetType_descriptor(), value);
}
inline bool TimerTaskTargetType_Parse(
    const ::std::string& name, TimerTaskTargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimerTaskTargetType>(
    TimerTaskTargetType_descriptor(), name, value);
}
enum TimerTaskCommandId {
  TIMER_TASK_SPEED_UP = 301,
  TIMER_TASK_COMPLETE = 302,
  TIMER_TASK_CANCEL = 303
};
bool TimerTaskCommandId_IsValid(int value);
const TimerTaskCommandId TimerTaskCommandId_MIN = TIMER_TASK_SPEED_UP;
const TimerTaskCommandId TimerTaskCommandId_MAX = TIMER_TASK_CANCEL;
const int TimerTaskCommandId_ARRAYSIZE = TimerTaskCommandId_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimerTaskCommandId_descriptor();
inline const ::std::string& TimerTaskCommandId_Name(TimerTaskCommandId value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimerTaskCommandId_descriptor(), value);
}
inline bool TimerTaskCommandId_Parse(
    const ::std::string& name, TimerTaskCommandId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimerTaskCommandId>(
    TimerTaskCommandId_descriptor(), name, value);
}
enum TimerTaskSpeedUpType {
  FREE = 1,
  USE_DIAMOND = 2,
  USE_ITEM = 3
};
bool TimerTaskSpeedUpType_IsValid(int value);
const TimerTaskSpeedUpType TimerTaskSpeedUpType_MIN = FREE;
const TimerTaskSpeedUpType TimerTaskSpeedUpType_MAX = USE_ITEM;
const int TimerTaskSpeedUpType_ARRAYSIZE = TimerTaskSpeedUpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimerTaskSpeedUpType_descriptor();
inline const ::std::string& TimerTaskSpeedUpType_Name(TimerTaskSpeedUpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimerTaskSpeedUpType_descriptor(), value);
}
inline bool TimerTaskSpeedUpType_Parse(
    const ::std::string& name, TimerTaskSpeedUpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimerTaskSpeedUpType>(
    TimerTaskSpeedUpType_descriptor(), name, value);
}
enum TimerTaskPushId {
  TIMER_TASK_LIST_PUSH = 50300,
  TIMER_TASK_COMPLETE_PUSH = 50302,
  TIMER_TASK_ADJUST_PUSH = 50303
};
bool TimerTaskPushId_IsValid(int value);
const TimerTaskPushId TimerTaskPushId_MIN = TIMER_TASK_LIST_PUSH;
const TimerTaskPushId TimerTaskPushId_MAX = TIMER_TASK_ADJUST_PUSH;
const int TimerTaskPushId_ARRAYSIZE = TimerTaskPushId_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimerTaskPushId_descriptor();
inline const ::std::string& TimerTaskPushId_Name(TimerTaskPushId value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimerTaskPushId_descriptor(), value);
}
inline bool TimerTaskPushId_Parse(
    const ::std::string& name, TimerTaskPushId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimerTaskPushId>(
    TimerTaskPushId_descriptor(), name, value);
}
// ===================================================================

class TimerTaskTargetDTO : public ::google::protobuf::Message {
 public:
  TimerTaskTargetDTO();
  virtual ~TimerTaskTargetDTO();

  TimerTaskTargetDTO(const TimerTaskTargetDTO& from);

  inline TimerTaskTargetDTO& operator=(const TimerTaskTargetDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskTargetDTO& default_instance();

  void Swap(TimerTaskTargetDTO* other);

  // implements Message ----------------------------------------------

  TimerTaskTargetDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskTargetDTO& from);
  void MergeFrom(const TimerTaskTargetDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.TimerTaskTargetType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::slg::protocol::TimerTaskTargetType type() const;
  inline void set_type(::slg::protocol::TimerTaskTargetType value);

  // required int32 targetId = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskTargetDTO)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskTargetDTO* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskDTO : public ::google::protobuf::Message {
 public:
  TimerTaskDTO();
  virtual ~TimerTaskDTO();

  TimerTaskDTO(const TimerTaskDTO& from);

  inline TimerTaskDTO& operator=(const TimerTaskDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskDTO& default_instance();

  void Swap(TimerTaskDTO* other);

  // implements Message ----------------------------------------------

  TimerTaskDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskDTO& from);
  void MergeFrom(const TimerTaskDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 startTs = 2;
  inline bool has_startts() const;
  inline void clear_startts();
  static const int kStartTsFieldNumber = 2;
  inline ::google::protobuf::int32 startts() const;
  inline void set_startts(::google::protobuf::int32 value);

  // required int32 endTs = 3;
  inline bool has_endts() const;
  inline void clear_endts();
  static const int kEndTsFieldNumber = 3;
  inline ::google::protobuf::int32 endts() const;
  inline void set_endts(::google::protobuf::int32 value);

  // required .slg.protocol.TimerTaskTargetDTO target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::slg::protocol::TimerTaskTargetDTO& target() const;
  inline ::slg::protocol::TimerTaskTargetDTO* mutable_target();
  inline ::slg::protocol::TimerTaskTargetDTO* release_target();
  inline void set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskDTO)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_startts();
  inline void clear_has_startts();
  inline void set_has_endts();
  inline void clear_has_endts();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 startts_;
  ::slg::protocol::TimerTaskTargetDTO* target_;
  ::google::protobuf::int32 endts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskDTO* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskCompleteRequest : public ::google::protobuf::Message {
 public:
  TimerTaskCompleteRequest();
  virtual ~TimerTaskCompleteRequest();

  TimerTaskCompleteRequest(const TimerTaskCompleteRequest& from);

  inline TimerTaskCompleteRequest& operator=(const TimerTaskCompleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskCompleteRequest& default_instance();

  void Swap(TimerTaskCompleteRequest* other);

  // implements Message ----------------------------------------------

  TimerTaskCompleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskCompleteRequest& from);
  void MergeFrom(const TimerTaskCompleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskCompleteRequest)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskCompleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskCompleteResponse : public ::google::protobuf::Message {
 public:
  TimerTaskCompleteResponse();
  virtual ~TimerTaskCompleteResponse();

  TimerTaskCompleteResponse(const TimerTaskCompleteResponse& from);

  inline TimerTaskCompleteResponse& operator=(const TimerTaskCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskCompleteResponse& default_instance();

  void Swap(TimerTaskCompleteResponse* other);

  // implements Message ----------------------------------------------

  TimerTaskCompleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskCompleteResponse& from);
  void MergeFrom(const TimerTaskCompleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 2;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 2;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskCompleteResponse)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskCompleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskSpeedUpRequest : public ::google::protobuf::Message {
 public:
  TimerTaskSpeedUpRequest();
  virtual ~TimerTaskSpeedUpRequest();

  TimerTaskSpeedUpRequest(const TimerTaskSpeedUpRequest& from);

  inline TimerTaskSpeedUpRequest& operator=(const TimerTaskSpeedUpRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskSpeedUpRequest& default_instance();

  void Swap(TimerTaskSpeedUpRequest* other);

  // implements Message ----------------------------------------------

  TimerTaskSpeedUpRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskSpeedUpRequest& from);
  void MergeFrom(const TimerTaskSpeedUpRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // optional .slg.protocol.TimerTaskSpeedUpType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::slg::protocol::TimerTaskSpeedUpType type() const;
  inline void set_type(::slg::protocol::TimerTaskSpeedUpType value);

  // optional .slg.protocol.ItemDTO item = 3;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::slg::protocol::ItemDTO& item() const;
  inline ::slg::protocol::ItemDTO* mutable_item();
  inline ::slg::protocol::ItemDTO* release_item();
  inline void set_allocated_item(::slg::protocol::ItemDTO* item);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskSpeedUpRequest)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timertaskid_;
  int type_;
  ::slg::protocol::ItemDTO* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskSpeedUpRequest* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskSpeedUpResponse : public ::google::protobuf::Message {
 public:
  TimerTaskSpeedUpResponse();
  virtual ~TimerTaskSpeedUpResponse();

  TimerTaskSpeedUpResponse(const TimerTaskSpeedUpResponse& from);

  inline TimerTaskSpeedUpResponse& operator=(const TimerTaskSpeedUpResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskSpeedUpResponse& default_instance();

  void Swap(TimerTaskSpeedUpResponse* other);

  // implements Message ----------------------------------------------

  TimerTaskSpeedUpResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskSpeedUpResponse& from);
  void MergeFrom(const TimerTaskSpeedUpResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // repeated .slg.protocol.PropertyDTO costProperties = 2;
  inline int costproperties_size() const;
  inline void clear_costproperties();
  static const int kCostPropertiesFieldNumber = 2;
  inline const ::slg::protocol::PropertyDTO& costproperties(int index) const;
  inline ::slg::protocol::PropertyDTO* mutable_costproperties(int index);
  inline ::slg::protocol::PropertyDTO* add_costproperties();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::PropertyDTO >&
      costproperties() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::PropertyDTO >*
      mutable_costproperties();

  // optional .slg.protocol.ItemDTO costItem = 3;
  inline bool has_costitem() const;
  inline void clear_costitem();
  static const int kCostItemFieldNumber = 3;
  inline const ::slg::protocol::ItemDTO& costitem() const;
  inline ::slg::protocol::ItemDTO* mutable_costitem();
  inline ::slg::protocol::ItemDTO* release_costitem();
  inline void set_allocated_costitem(::slg::protocol::ItemDTO* costitem);

  // required .slg.protocol.TimerTaskTargetDTO target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::slg::protocol::TimerTaskTargetDTO& target() const;
  inline ::slg::protocol::TimerTaskTargetDTO* mutable_target();
  inline ::slg::protocol::TimerTaskTargetDTO* release_target();
  inline void set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskSpeedUpResponse)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();
  inline void set_has_costitem();
  inline void clear_has_costitem();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::slg::protocol::PropertyDTO > costproperties_;
  ::slg::protocol::ItemDTO* costitem_;
  ::slg::protocol::TimerTaskTargetDTO* target_;
  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskSpeedUpResponse* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskCancelRequest : public ::google::protobuf::Message {
 public:
  TimerTaskCancelRequest();
  virtual ~TimerTaskCancelRequest();

  TimerTaskCancelRequest(const TimerTaskCancelRequest& from);

  inline TimerTaskCancelRequest& operator=(const TimerTaskCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskCancelRequest& default_instance();

  void Swap(TimerTaskCancelRequest* other);

  // implements Message ----------------------------------------------

  TimerTaskCancelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskCancelRequest& from);
  void MergeFrom(const TimerTaskCancelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskCancelRequest)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskCancelRequest* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskCancelResponse : public ::google::protobuf::Message {
 public:
  TimerTaskCancelResponse();
  virtual ~TimerTaskCancelResponse();

  TimerTaskCancelResponse(const TimerTaskCancelResponse& from);

  inline TimerTaskCancelResponse& operator=(const TimerTaskCancelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskCancelResponse& default_instance();

  void Swap(TimerTaskCancelResponse* other);

  // implements Message ----------------------------------------------

  TimerTaskCancelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskCancelResponse& from);
  void MergeFrom(const TimerTaskCancelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // required .slg.protocol.TimerTaskTargetDTO target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::slg::protocol::TimerTaskTargetDTO& target() const;
  inline ::slg::protocol::TimerTaskTargetDTO* mutable_target();
  inline ::slg::protocol::TimerTaskTargetDTO* release_target();
  inline void set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskCancelResponse)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::TimerTaskTargetDTO* target_;
  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskCancelResponse* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskListPush : public ::google::protobuf::Message {
 public:
  TimerTaskListPush();
  virtual ~TimerTaskListPush();

  TimerTaskListPush(const TimerTaskListPush& from);

  inline TimerTaskListPush& operator=(const TimerTaskListPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskListPush& default_instance();

  void Swap(TimerTaskListPush* other);

  // implements Message ----------------------------------------------

  TimerTaskListPush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskListPush& from);
  void MergeFrom(const TimerTaskListPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .slg.protocol.TimerTaskDTO timerTasks = 1;
  inline int timertasks_size() const;
  inline void clear_timertasks();
  static const int kTimerTasksFieldNumber = 1;
  inline const ::slg::protocol::TimerTaskDTO& timertasks(int index) const;
  inline ::slg::protocol::TimerTaskDTO* mutable_timertasks(int index);
  inline ::slg::protocol::TimerTaskDTO* add_timertasks();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::TimerTaskDTO >&
      timertasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::TimerTaskDTO >*
      mutable_timertasks();

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskListPush)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::slg::protocol::TimerTaskDTO > timertasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskListPush* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskCompletePush : public ::google::protobuf::Message {
 public:
  TimerTaskCompletePush();
  virtual ~TimerTaskCompletePush();

  TimerTaskCompletePush(const TimerTaskCompletePush& from);

  inline TimerTaskCompletePush& operator=(const TimerTaskCompletePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskCompletePush& default_instance();

  void Swap(TimerTaskCompletePush* other);

  // implements Message ----------------------------------------------

  TimerTaskCompletePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskCompletePush& from);
  void MergeFrom(const TimerTaskCompletePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // required .slg.protocol.TimerTaskTargetDTO target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::slg::protocol::TimerTaskTargetDTO& target() const;
  inline ::slg::protocol::TimerTaskTargetDTO* mutable_target();
  inline ::slg::protocol::TimerTaskTargetDTO* release_target();
  inline void set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskCompletePush)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::TimerTaskTargetDTO* target_;
  ::google::protobuf::int32 timertaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskCompletePush* default_instance_;
};
// -------------------------------------------------------------------

class TimerTaskAdjustPush : public ::google::protobuf::Message {
 public:
  TimerTaskAdjustPush();
  virtual ~TimerTaskAdjustPush();

  TimerTaskAdjustPush(const TimerTaskAdjustPush& from);

  inline TimerTaskAdjustPush& operator=(const TimerTaskAdjustPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerTaskAdjustPush& default_instance();

  void Swap(TimerTaskAdjustPush* other);

  // implements Message ----------------------------------------------

  TimerTaskAdjustPush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerTaskAdjustPush& from);
  void MergeFrom(const TimerTaskAdjustPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timerTaskId = 1;
  inline bool has_timertaskid() const;
  inline void clear_timertaskid();
  static const int kTimerTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 timertaskid() const;
  inline void set_timertaskid(::google::protobuf::int32 value);

  // required int32 systime = 2;
  inline bool has_systime() const;
  inline void clear_systime();
  static const int kSystimeFieldNumber = 2;
  inline ::google::protobuf::int32 systime() const;
  inline void set_systime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.TimerTaskAdjustPush)
 private:
  inline void set_has_timertaskid();
  inline void clear_has_timertaskid();
  inline void set_has_systime();
  inline void clear_has_systime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timertaskid_;
  ::google::protobuf::int32 systime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_timer_5ftask_2eproto();
  friend void protobuf_AssignDesc_timer_5ftask_2eproto();
  friend void protobuf_ShutdownFile_timer_5ftask_2eproto();

  void InitAsDefaultInstance();
  static TimerTaskAdjustPush* default_instance_;
};
// ===================================================================


// ===================================================================

// TimerTaskTargetDTO

// required .slg.protocol.TimerTaskTargetType type = 1;
inline bool TimerTaskTargetDTO::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskTargetDTO::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskTargetDTO::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskTargetDTO::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::slg::protocol::TimerTaskTargetType TimerTaskTargetDTO::type() const {
  return static_cast< ::slg::protocol::TimerTaskTargetType >(type_);
}
inline void TimerTaskTargetDTO::set_type(::slg::protocol::TimerTaskTargetType value) {
  assert(::slg::protocol::TimerTaskTargetType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 targetId = 2;
inline bool TimerTaskTargetDTO::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskTargetDTO::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskTargetDTO::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskTargetDTO::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 TimerTaskTargetDTO::targetid() const {
  return targetid_;
}
inline void TimerTaskTargetDTO::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// TimerTaskDTO

// required int32 id = 1;
inline bool TimerTaskDTO::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskDTO::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskDTO::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskDTO::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TimerTaskDTO::id() const {
  return id_;
}
inline void TimerTaskDTO::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 startTs = 2;
inline bool TimerTaskDTO::has_startts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskDTO::set_has_startts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskDTO::clear_has_startts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskDTO::clear_startts() {
  startts_ = 0;
  clear_has_startts();
}
inline ::google::protobuf::int32 TimerTaskDTO::startts() const {
  return startts_;
}
inline void TimerTaskDTO::set_startts(::google::protobuf::int32 value) {
  set_has_startts();
  startts_ = value;
}

// required int32 endTs = 3;
inline bool TimerTaskDTO::has_endts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimerTaskDTO::set_has_endts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimerTaskDTO::clear_has_endts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimerTaskDTO::clear_endts() {
  endts_ = 0;
  clear_has_endts();
}
inline ::google::protobuf::int32 TimerTaskDTO::endts() const {
  return endts_;
}
inline void TimerTaskDTO::set_endts(::google::protobuf::int32 value) {
  set_has_endts();
  endts_ = value;
}

// required .slg.protocol.TimerTaskTargetDTO target = 4;
inline bool TimerTaskDTO::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimerTaskDTO::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimerTaskDTO::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimerTaskDTO::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::TimerTaskTargetDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::TimerTaskTargetDTO& TimerTaskDTO::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskDTO::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::TimerTaskTargetDTO;
  return target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskDTO::release_target() {
  clear_has_target();
  ::slg::protocol::TimerTaskTargetDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void TimerTaskDTO::set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// TimerTaskCompleteRequest

// required int32 timerTaskId = 1;
inline bool TimerTaskCompleteRequest::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskCompleteRequest::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskCompleteRequest::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskCompleteRequest::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskCompleteRequest::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskCompleteRequest::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// -------------------------------------------------------------------

// TimerTaskCompleteResponse

// required int32 timerTaskId = 2;
inline bool TimerTaskCompleteResponse::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskCompleteResponse::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskCompleteResponse::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskCompleteResponse::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskCompleteResponse::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskCompleteResponse::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// -------------------------------------------------------------------

// TimerTaskSpeedUpRequest

// required int32 timerTaskId = 1;
inline bool TimerTaskSpeedUpRequest::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskSpeedUpRequest::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskSpeedUpRequest::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskSpeedUpRequest::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskSpeedUpRequest::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskSpeedUpRequest::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// optional .slg.protocol.TimerTaskSpeedUpType type = 2;
inline bool TimerTaskSpeedUpRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskSpeedUpRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskSpeedUpRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskSpeedUpRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::slg::protocol::TimerTaskSpeedUpType TimerTaskSpeedUpRequest::type() const {
  return static_cast< ::slg::protocol::TimerTaskSpeedUpType >(type_);
}
inline void TimerTaskSpeedUpRequest::set_type(::slg::protocol::TimerTaskSpeedUpType value) {
  assert(::slg::protocol::TimerTaskSpeedUpType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .slg.protocol.ItemDTO item = 3;
inline bool TimerTaskSpeedUpRequest::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimerTaskSpeedUpRequest::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimerTaskSpeedUpRequest::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimerTaskSpeedUpRequest::clear_item() {
  if (item_ != NULL) item_->::slg::protocol::ItemDTO::Clear();
  clear_has_item();
}
inline const ::slg::protocol::ItemDTO& TimerTaskSpeedUpRequest::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::slg::protocol::ItemDTO* TimerTaskSpeedUpRequest::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::slg::protocol::ItemDTO;
  return item_;
}
inline ::slg::protocol::ItemDTO* TimerTaskSpeedUpRequest::release_item() {
  clear_has_item();
  ::slg::protocol::ItemDTO* temp = item_;
  item_ = NULL;
  return temp;
}
inline void TimerTaskSpeedUpRequest::set_allocated_item(::slg::protocol::ItemDTO* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// TimerTaskSpeedUpResponse

// required int32 timerTaskId = 1;
inline bool TimerTaskSpeedUpResponse::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskSpeedUpResponse::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskSpeedUpResponse::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskSpeedUpResponse::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskSpeedUpResponse::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskSpeedUpResponse::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// repeated .slg.protocol.PropertyDTO costProperties = 2;
inline int TimerTaskSpeedUpResponse::costproperties_size() const {
  return costproperties_.size();
}
inline void TimerTaskSpeedUpResponse::clear_costproperties() {
  costproperties_.Clear();
}
inline const ::slg::protocol::PropertyDTO& TimerTaskSpeedUpResponse::costproperties(int index) const {
  return costproperties_.Get(index);
}
inline ::slg::protocol::PropertyDTO* TimerTaskSpeedUpResponse::mutable_costproperties(int index) {
  return costproperties_.Mutable(index);
}
inline ::slg::protocol::PropertyDTO* TimerTaskSpeedUpResponse::add_costproperties() {
  return costproperties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::PropertyDTO >&
TimerTaskSpeedUpResponse::costproperties() const {
  return costproperties_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::PropertyDTO >*
TimerTaskSpeedUpResponse::mutable_costproperties() {
  return &costproperties_;
}

// optional .slg.protocol.ItemDTO costItem = 3;
inline bool TimerTaskSpeedUpResponse::has_costitem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimerTaskSpeedUpResponse::set_has_costitem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimerTaskSpeedUpResponse::clear_has_costitem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimerTaskSpeedUpResponse::clear_costitem() {
  if (costitem_ != NULL) costitem_->::slg::protocol::ItemDTO::Clear();
  clear_has_costitem();
}
inline const ::slg::protocol::ItemDTO& TimerTaskSpeedUpResponse::costitem() const {
  return costitem_ != NULL ? *costitem_ : *default_instance_->costitem_;
}
inline ::slg::protocol::ItemDTO* TimerTaskSpeedUpResponse::mutable_costitem() {
  set_has_costitem();
  if (costitem_ == NULL) costitem_ = new ::slg::protocol::ItemDTO;
  return costitem_;
}
inline ::slg::protocol::ItemDTO* TimerTaskSpeedUpResponse::release_costitem() {
  clear_has_costitem();
  ::slg::protocol::ItemDTO* temp = costitem_;
  costitem_ = NULL;
  return temp;
}
inline void TimerTaskSpeedUpResponse::set_allocated_costitem(::slg::protocol::ItemDTO* costitem) {
  delete costitem_;
  costitem_ = costitem;
  if (costitem) {
    set_has_costitem();
  } else {
    clear_has_costitem();
  }
}

// required .slg.protocol.TimerTaskTargetDTO target = 4;
inline bool TimerTaskSpeedUpResponse::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimerTaskSpeedUpResponse::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimerTaskSpeedUpResponse::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimerTaskSpeedUpResponse::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::TimerTaskTargetDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::TimerTaskTargetDTO& TimerTaskSpeedUpResponse::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskSpeedUpResponse::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::TimerTaskTargetDTO;
  return target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskSpeedUpResponse::release_target() {
  clear_has_target();
  ::slg::protocol::TimerTaskTargetDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void TimerTaskSpeedUpResponse::set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// TimerTaskCancelRequest

// required int32 timerTaskId = 1;
inline bool TimerTaskCancelRequest::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskCancelRequest::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskCancelRequest::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskCancelRequest::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskCancelRequest::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskCancelRequest::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// -------------------------------------------------------------------

// TimerTaskCancelResponse

// required int32 timerTaskId = 1;
inline bool TimerTaskCancelResponse::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskCancelResponse::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskCancelResponse::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskCancelResponse::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskCancelResponse::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskCancelResponse::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// required .slg.protocol.TimerTaskTargetDTO target = 2;
inline bool TimerTaskCancelResponse::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskCancelResponse::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskCancelResponse::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskCancelResponse::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::TimerTaskTargetDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::TimerTaskTargetDTO& TimerTaskCancelResponse::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskCancelResponse::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::TimerTaskTargetDTO;
  return target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskCancelResponse::release_target() {
  clear_has_target();
  ::slg::protocol::TimerTaskTargetDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void TimerTaskCancelResponse::set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// TimerTaskListPush

// repeated .slg.protocol.TimerTaskDTO timerTasks = 1;
inline int TimerTaskListPush::timertasks_size() const {
  return timertasks_.size();
}
inline void TimerTaskListPush::clear_timertasks() {
  timertasks_.Clear();
}
inline const ::slg::protocol::TimerTaskDTO& TimerTaskListPush::timertasks(int index) const {
  return timertasks_.Get(index);
}
inline ::slg::protocol::TimerTaskDTO* TimerTaskListPush::mutable_timertasks(int index) {
  return timertasks_.Mutable(index);
}
inline ::slg::protocol::TimerTaskDTO* TimerTaskListPush::add_timertasks() {
  return timertasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::TimerTaskDTO >&
TimerTaskListPush::timertasks() const {
  return timertasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::TimerTaskDTO >*
TimerTaskListPush::mutable_timertasks() {
  return &timertasks_;
}

// -------------------------------------------------------------------

// TimerTaskCompletePush

// required int32 timerTaskId = 1;
inline bool TimerTaskCompletePush::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskCompletePush::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskCompletePush::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskCompletePush::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskCompletePush::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskCompletePush::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// required .slg.protocol.TimerTaskTargetDTO target = 2;
inline bool TimerTaskCompletePush::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskCompletePush::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskCompletePush::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskCompletePush::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::TimerTaskTargetDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::TimerTaskTargetDTO& TimerTaskCompletePush::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskCompletePush::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::TimerTaskTargetDTO;
  return target_;
}
inline ::slg::protocol::TimerTaskTargetDTO* TimerTaskCompletePush::release_target() {
  clear_has_target();
  ::slg::protocol::TimerTaskTargetDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void TimerTaskCompletePush::set_allocated_target(::slg::protocol::TimerTaskTargetDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// TimerTaskAdjustPush

// required int32 timerTaskId = 1;
inline bool TimerTaskAdjustPush::has_timertaskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerTaskAdjustPush::set_has_timertaskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerTaskAdjustPush::clear_has_timertaskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerTaskAdjustPush::clear_timertaskid() {
  timertaskid_ = 0;
  clear_has_timertaskid();
}
inline ::google::protobuf::int32 TimerTaskAdjustPush::timertaskid() const {
  return timertaskid_;
}
inline void TimerTaskAdjustPush::set_timertaskid(::google::protobuf::int32 value) {
  set_has_timertaskid();
  timertaskid_ = value;
}

// required int32 systime = 2;
inline bool TimerTaskAdjustPush::has_systime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimerTaskAdjustPush::set_has_systime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimerTaskAdjustPush::clear_has_systime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimerTaskAdjustPush::clear_systime() {
  systime_ = 0;
  clear_has_systime();
}
inline ::google::protobuf::int32 TimerTaskAdjustPush::systime() const {
  return systime_;
}
inline void TimerTaskAdjustPush::set_systime(::google::protobuf::int32 value) {
  set_has_systime();
  systime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace slg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::TimerTaskTargetType>() {
  return ::slg::protocol::TimerTaskTargetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::TimerTaskCommandId>() {
  return ::slg::protocol::TimerTaskCommandId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::TimerTaskSpeedUpType>() {
  return ::slg::protocol::TimerTaskSpeedUpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::TimerTaskPushId>() {
  return ::slg::protocol::TimerTaskPushId_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_timer_5ftask_2eproto__INCLUDED
