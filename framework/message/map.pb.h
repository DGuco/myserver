// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.proto

#ifndef PROTOBUF_map_2eproto__INCLUDED
#define PROTOBUF_map_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace slg {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2eproto();
void protobuf_AssignDesc_map_2eproto();
void protobuf_ShutdownFile_map_2eproto();

class MapGridDTO;
class MapPlayerProfileDTO;
class MapResourceOccupierDTO;
class MapPlayerGridDTO;
class MapResourceGridDTO;
class MapMonsterGridDTO;
class MapObstacleGridDTO;
class FaroriteDTO;
class MapQueryRequest;
class MapPlayerMigrateRequest;
class MapPlayerMigrateResponse;
class MapGridSearchRequest;
class MapGridSearchResponse;
class FaroriteListRequest;
class FaroriteListResponse;
class FaroriteRequest;
class FavoriteResponse;
class FaroriteRemoveRequest;
class FaroriteRemoveResponse;
class MapGridListPush;
class MapGridRemovePush;
class MonsterProgress;
class MapMonsterProgressPush;

enum MapGridType {
  MAP_GRID_TYPE_RESOURCE = 1,
  MAP_GRID_TYPE_PLAYER = 2,
  MAP_GRID_TYPE_MONSTER = 3,
  MAP_GRID_TYPE_ALLIANCE = 4,
  MAP_GRID_TYPE_OBSTACLE = 5,
  MAP_GRID_TYPE_EMPTY = 6
};
bool MapGridType_IsValid(int value);
const MapGridType MapGridType_MIN = MAP_GRID_TYPE_RESOURCE;
const MapGridType MapGridType_MAX = MAP_GRID_TYPE_EMPTY;
const int MapGridType_ARRAYSIZE = MapGridType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapGridType_descriptor();
inline const ::std::string& MapGridType_Name(MapGridType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapGridType_descriptor(), value);
}
inline bool MapGridType_Parse(
    const ::std::string& name, MapGridType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapGridType>(
    MapGridType_descriptor(), name, value);
}
enum MapCommandId {
  MAP_QUERY = 701,
  MAP_EXIT = 702,
  MAP_ENTER = 703,
  MAP_PLAYER_MIGRATE = 704,
  MAP_GRID_SEARCH = 705,
  MAP_FAVORITE_LIST = 706,
  MAP_ADD_FAVORITE = 707,
  MAP_REMOVE_FAVORITE = 708
};
bool MapCommandId_IsValid(int value);
const MapCommandId MapCommandId_MIN = MAP_QUERY;
const MapCommandId MapCommandId_MAX = MAP_REMOVE_FAVORITE;
const int MapCommandId_ARRAYSIZE = MapCommandId_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapCommandId_descriptor();
inline const ::std::string& MapCommandId_Name(MapCommandId value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapCommandId_descriptor(), value);
}
inline bool MapCommandId_Parse(
    const ::std::string& name, MapCommandId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapCommandId>(
    MapCommandId_descriptor(), name, value);
}
enum MapGridSearchType {
  MAP_MONSTER = 1,
  MAP_GOLD_GRID = 2,
  MAP_WOOD_GRID = 3,
  MAP_STONE_GRID = 4,
  MAP_IRON_GRID = 5,
  MAP_DIAMOND_GRID = 6
};
bool MapGridSearchType_IsValid(int value);
const MapGridSearchType MapGridSearchType_MIN = MAP_MONSTER;
const MapGridSearchType MapGridSearchType_MAX = MAP_DIAMOND_GRID;
const int MapGridSearchType_ARRAYSIZE = MapGridSearchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapGridSearchType_descriptor();
inline const ::std::string& MapGridSearchType_Name(MapGridSearchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapGridSearchType_descriptor(), value);
}
inline bool MapGridSearchType_Parse(
    const ::std::string& name, MapGridSearchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapGridSearchType>(
    MapGridSearchType_descriptor(), name, value);
}
enum MapPushId {
  MAP_PUSH_GRID_LIST = 50701,
  MAP_PUSH_GRID_REMOVE = 50702,
  MAP_PUSH_MONSTER_PROGRESSES = 50703
};
bool MapPushId_IsValid(int value);
const MapPushId MapPushId_MIN = MAP_PUSH_GRID_LIST;
const MapPushId MapPushId_MAX = MAP_PUSH_MONSTER_PROGRESSES;
const int MapPushId_ARRAYSIZE = MapPushId_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapPushId_descriptor();
inline const ::std::string& MapPushId_Name(MapPushId value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapPushId_descriptor(), value);
}
inline bool MapPushId_Parse(
    const ::std::string& name, MapPushId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapPushId>(
    MapPushId_descriptor(), name, value);
}
// ===================================================================

class MapGridDTO : public ::google::protobuf::Message {
 public:
  MapGridDTO();
  virtual ~MapGridDTO();

  MapGridDTO(const MapGridDTO& from);

  inline MapGridDTO& operator=(const MapGridDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGridDTO& default_instance();

  void Swap(MapGridDTO* other);

  // implements Message ----------------------------------------------

  MapGridDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapGridDTO& from);
  void MergeFrom(const MapGridDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& location() const;
  inline ::slg::protocol::PositionDTO* mutable_location();
  inline ::slg::protocol::PositionDTO* release_location();
  inline void set_allocated_location(::slg::protocol::PositionDTO* location);

  // required .slg.protocol.MapGridType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::slg::protocol::MapGridType type() const;
  inline void set_type(::slg::protocol::MapGridType value);

  // required bytes detail = 3;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 3;
  inline const ::std::string& detail() const;
  inline void set_detail(const ::std::string& value);
  inline void set_detail(const char* value);
  inline void set_detail(const void* value, size_t size);
  inline ::std::string* mutable_detail();
  inline ::std::string* release_detail();
  inline void set_allocated_detail(::std::string* detail);

  // required int64 objId = 4;
  inline bool has_objid() const;
  inline void clear_objid();
  static const int kObjIdFieldNumber = 4;
  inline ::google::protobuf::int64 objid() const;
  inline void set_objid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapGridDTO)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_objid();
  inline void clear_has_objid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* location_;
  ::std::string* detail_;
  ::google::protobuf::int64 objid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapGridDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapPlayerProfileDTO : public ::google::protobuf::Message {
 public:
  MapPlayerProfileDTO();
  virtual ~MapPlayerProfileDTO();

  MapPlayerProfileDTO(const MapPlayerProfileDTO& from);

  inline MapPlayerProfileDTO& operator=(const MapPlayerProfileDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPlayerProfileDTO& default_instance();

  void Swap(MapPlayerProfileDTO* other);

  // implements Message ----------------------------------------------

  MapPlayerProfileDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPlayerProfileDTO& from);
  void MergeFrom(const MapPlayerProfileDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // required int32 castleLevel = 4;
  inline bool has_castlelevel() const;
  inline void clear_castlelevel();
  static const int kCastleLevelFieldNumber = 4;
  inline ::google::protobuf::int32 castlelevel() const;
  inline void set_castlelevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapPlayerProfileDTO)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_castlelevel();
  inline void clear_has_castlelevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 playerid_;
  ::std::string* nickname_;
  ::std::string* icon_;
  ::google::protobuf::int32 castlelevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapPlayerProfileDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapResourceOccupierDTO : public ::google::protobuf::Message {
 public:
  MapResourceOccupierDTO();
  virtual ~MapResourceOccupierDTO();

  MapResourceOccupierDTO(const MapResourceOccupierDTO& from);

  inline MapResourceOccupierDTO& operator=(const MapResourceOccupierDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapResourceOccupierDTO& default_instance();

  void Swap(MapResourceOccupierDTO* other);

  // implements Message ----------------------------------------------

  MapResourceOccupierDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapResourceOccupierDTO& from);
  void MergeFrom(const MapResourceOccupierDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.MapPlayerProfileDTO player = 1;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 1;
  inline const ::slg::protocol::MapPlayerProfileDTO& player() const;
  inline ::slg::protocol::MapPlayerProfileDTO* mutable_player();
  inline ::slg::protocol::MapPlayerProfileDTO* release_player();
  inline void set_allocated_player(::slg::protocol::MapPlayerProfileDTO* player);

  // repeated .slg.protocol.LevelSoldierDTO soldiers = 2;
  inline int soldiers_size() const;
  inline void clear_soldiers();
  static const int kSoldiersFieldNumber = 2;
  inline const ::slg::protocol::LevelSoldierDTO& soldiers(int index) const;
  inline ::slg::protocol::LevelSoldierDTO* mutable_soldiers(int index);
  inline ::slg::protocol::LevelSoldierDTO* add_soldiers();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::LevelSoldierDTO >&
      soldiers() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::LevelSoldierDTO >*
      mutable_soldiers();

  // required int32 gatherTime = 4;
  inline bool has_gathertime() const;
  inline void clear_gathertime();
  static const int kGatherTimeFieldNumber = 4;
  inline ::google::protobuf::int32 gathertime() const;
  inline void set_gathertime(::google::protobuf::int32 value);

  // required int32 gatherNum = 5;
  inline bool has_gathernum() const;
  inline void clear_gathernum();
  static const int kGatherNumFieldNumber = 5;
  inline ::google::protobuf::int32 gathernum() const;
  inline void set_gathernum(::google::protobuf::int32 value);

  // required int32 gatherRate = 6;
  inline bool has_gatherrate() const;
  inline void clear_gatherrate();
  static const int kGatherRateFieldNumber = 6;
  inline ::google::protobuf::int32 gatherrate() const;
  inline void set_gatherrate(::google::protobuf::int32 value);

  // optional int32 addRate = 7;
  inline bool has_addrate() const;
  inline void clear_addrate();
  static const int kAddRateFieldNumber = 7;
  inline ::google::protobuf::int32 addrate() const;
  inline void set_addrate(::google::protobuf::int32 value);

  // optional int64 marchid = 8;
  inline bool has_marchid() const;
  inline void clear_marchid();
  static const int kMarchidFieldNumber = 8;
  inline ::google::protobuf::int64 marchid() const;
  inline void set_marchid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapResourceOccupierDTO)
 private:
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_gathertime();
  inline void clear_has_gathertime();
  inline void set_has_gathernum();
  inline void clear_has_gathernum();
  inline void set_has_gatherrate();
  inline void clear_has_gatherrate();
  inline void set_has_addrate();
  inline void clear_has_addrate();
  inline void set_has_marchid();
  inline void clear_has_marchid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::MapPlayerProfileDTO* player_;
  ::google::protobuf::RepeatedPtrField< ::slg::protocol::LevelSoldierDTO > soldiers_;
  ::google::protobuf::int32 gathertime_;
  ::google::protobuf::int32 gathernum_;
  ::google::protobuf::int32 gatherrate_;
  ::google::protobuf::int32 addrate_;
  ::google::protobuf::int64 marchid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapResourceOccupierDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapPlayerGridDTO : public ::google::protobuf::Message {
 public:
  MapPlayerGridDTO();
  virtual ~MapPlayerGridDTO();

  MapPlayerGridDTO(const MapPlayerGridDTO& from);

  inline MapPlayerGridDTO& operator=(const MapPlayerGridDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPlayerGridDTO& default_instance();

  void Swap(MapPlayerGridDTO* other);

  // implements Message ----------------------------------------------

  MapPlayerGridDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPlayerGridDTO& from);
  void MergeFrom(const MapPlayerGridDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.MapPlayerProfileDTO player = 1;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 1;
  inline const ::slg::protocol::MapPlayerProfileDTO& player() const;
  inline ::slg::protocol::MapPlayerProfileDTO* mutable_player();
  inline ::slg::protocol::MapPlayerProfileDTO* release_player();
  inline void set_allocated_player(::slg::protocol::MapPlayerProfileDTO* player);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapPlayerGridDTO)
 private:
  inline void set_has_player();
  inline void clear_has_player();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::MapPlayerProfileDTO* player_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapPlayerGridDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapResourceGridDTO : public ::google::protobuf::Message {
 public:
  MapResourceGridDTO();
  virtual ~MapResourceGridDTO();

  MapResourceGridDTO(const MapResourceGridDTO& from);

  inline MapResourceGridDTO& operator=(const MapResourceGridDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapResourceGridDTO& default_instance();

  void Swap(MapResourceGridDTO* other);

  // implements Message ----------------------------------------------

  MapResourceGridDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapResourceGridDTO& from);
  void MergeFrom(const MapResourceGridDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 remain = 3;
  inline bool has_remain() const;
  inline void clear_remain();
  static const int kRemainFieldNumber = 3;
  inline ::google::protobuf::int32 remain() const;
  inline void set_remain(::google::protobuf::int32 value);

  // optional .slg.protocol.MapResourceOccupierDTO occupier = 9;
  inline bool has_occupier() const;
  inline void clear_occupier();
  static const int kOccupierFieldNumber = 9;
  inline const ::slg::protocol::MapResourceOccupierDTO& occupier() const;
  inline ::slg::protocol::MapResourceOccupierDTO* mutable_occupier();
  inline ::slg::protocol::MapResourceOccupierDTO* release_occupier();
  inline void set_allocated_occupier(::slg::protocol::MapResourceOccupierDTO* occupier);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapResourceGridDTO)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_remain();
  inline void clear_has_remain();
  inline void set_has_occupier();
  inline void clear_has_occupier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 level_;
  ::slg::protocol::MapResourceOccupierDTO* occupier_;
  ::google::protobuf::int32 remain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapResourceGridDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapMonsterGridDTO : public ::google::protobuf::Message {
 public:
  MapMonsterGridDTO();
  virtual ~MapMonsterGridDTO();

  MapMonsterGridDTO(const MapMonsterGridDTO& from);

  inline MapMonsterGridDTO& operator=(const MapMonsterGridDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapMonsterGridDTO& default_instance();

  void Swap(MapMonsterGridDTO* other);

  // implements Message ----------------------------------------------

  MapMonsterGridDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapMonsterGridDTO& from);
  void MergeFrom(const MapMonsterGridDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 configId = 1;
  inline bool has_configid() const;
  inline void clear_configid();
  static const int kConfigIdFieldNumber = 1;
  inline ::google::protobuf::int32 configid() const;
  inline void set_configid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapMonsterGridDTO)
 private:
  inline void set_has_configid();
  inline void clear_has_configid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 configid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapMonsterGridDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapObstacleGridDTO : public ::google::protobuf::Message {
 public:
  MapObstacleGridDTO();
  virtual ~MapObstacleGridDTO();

  MapObstacleGridDTO(const MapObstacleGridDTO& from);

  inline MapObstacleGridDTO& operator=(const MapObstacleGridDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapObstacleGridDTO& default_instance();

  void Swap(MapObstacleGridDTO* other);

  // implements Message ----------------------------------------------

  MapObstacleGridDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapObstacleGridDTO& from);
  void MergeFrom(const MapObstacleGridDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 configId = 1;
  inline bool has_configid() const;
  inline void clear_configid();
  static const int kConfigIdFieldNumber = 1;
  inline ::google::protobuf::int32 configid() const;
  inline void set_configid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapObstacleGridDTO)
 private:
  inline void set_has_configid();
  inline void clear_has_configid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 configid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapObstacleGridDTO* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteDTO : public ::google::protobuf::Message {
 public:
  FaroriteDTO();
  virtual ~FaroriteDTO();

  FaroriteDTO(const FaroriteDTO& from);

  inline FaroriteDTO& operator=(const FaroriteDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteDTO& default_instance();

  void Swap(FaroriteDTO* other);

  // implements Message ----------------------------------------------

  FaroriteDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteDTO& from);
  void MergeFrom(const FaroriteDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.MapGridType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::slg::protocol::MapGridType type() const;
  inline void set_type(::slg::protocol::MapGridType value);

  // required .slg.protocol.PositionDTO location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::slg::protocol::PositionDTO& location() const;
  inline ::slg::protocol::PositionDTO* mutable_location();
  inline ::slg::protocol::PositionDTO* release_location();
  inline void set_allocated_location(::slg::protocol::PositionDTO* location);

  // optional int32 subtype = 3;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubtypeFieldNumber = 3;
  inline ::google::protobuf::int32 subtype() const;
  inline void set_subtype(::google::protobuf::int32 value);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string playernme = 6;
  inline bool has_playernme() const;
  inline void clear_playernme();
  static const int kPlayernmeFieldNumber = 6;
  inline const ::std::string& playernme() const;
  inline void set_playernme(const ::std::string& value);
  inline void set_playernme(const char* value);
  inline void set_playernme(const char* value, size_t size);
  inline ::std::string* mutable_playernme();
  inline ::std::string* release_playernme();
  inline void set_allocated_playernme(::std::string* playernme);

  // optional int32 resourceNum = 7;
  inline bool has_resourcenum() const;
  inline void clear_resourcenum();
  static const int kResourceNumFieldNumber = 7;
  inline ::google::protobuf::int32 resourcenum() const;
  inline void set_resourcenum(::google::protobuf::int32 value);

  // optional string alliancename = 8;
  inline bool has_alliancename() const;
  inline void clear_alliancename();
  static const int kAlliancenameFieldNumber = 8;
  inline const ::std::string& alliancename() const;
  inline void set_alliancename(const ::std::string& value);
  inline void set_alliancename(const char* value);
  inline void set_alliancename(const char* value, size_t size);
  inline ::std::string* mutable_alliancename();
  inline ::std::string* release_alliancename();
  inline void set_allocated_alliancename(::std::string* alliancename);

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteDTO)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_playernme();
  inline void clear_has_playernme();
  inline void set_has_resourcenum();
  inline void clear_has_resourcenum();
  inline void set_has_alliancename();
  inline void clear_has_alliancename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* location_;
  int type_;
  ::google::protobuf::int32 subtype_;
  ::std::string* icon_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 resourcenum_;
  ::std::string* playernme_;
  ::std::string* alliancename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteDTO* default_instance_;
};
// -------------------------------------------------------------------

class MapQueryRequest : public ::google::protobuf::Message {
 public:
  MapQueryRequest();
  virtual ~MapQueryRequest();

  MapQueryRequest(const MapQueryRequest& from);

  inline MapQueryRequest& operator=(const MapQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapQueryRequest& default_instance();

  void Swap(MapQueryRequest* other);

  // implements Message ----------------------------------------------

  MapQueryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapQueryRequest& from);
  void MergeFrom(const MapQueryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& start() const;
  inline ::slg::protocol::PositionDTO* mutable_start();
  inline ::slg::protocol::PositionDTO* release_start();
  inline void set_allocated_start(::slg::protocol::PositionDTO* start);

  // required .slg.protocol.PositionDTO end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::slg::protocol::PositionDTO& end() const;
  inline ::slg::protocol::PositionDTO* mutable_end();
  inline ::slg::protocol::PositionDTO* release_end();
  inline void set_allocated_end(::slg::protocol::PositionDTO* end);

  // required .slg.protocol.PositionDTO center = 3;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 3;
  inline const ::slg::protocol::PositionDTO& center() const;
  inline ::slg::protocol::PositionDTO* mutable_center();
  inline ::slg::protocol::PositionDTO* release_center();
  inline void set_allocated_center(::slg::protocol::PositionDTO* center);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapQueryRequest)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_center();
  inline void clear_has_center();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* start_;
  ::slg::protocol::PositionDTO* end_;
  ::slg::protocol::PositionDTO* center_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapQueryRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapPlayerMigrateRequest : public ::google::protobuf::Message {
 public:
  MapPlayerMigrateRequest();
  virtual ~MapPlayerMigrateRequest();

  MapPlayerMigrateRequest(const MapPlayerMigrateRequest& from);

  inline MapPlayerMigrateRequest& operator=(const MapPlayerMigrateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPlayerMigrateRequest& default_instance();

  void Swap(MapPlayerMigrateRequest* other);

  // implements Message ----------------------------------------------

  MapPlayerMigrateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPlayerMigrateRequest& from);
  void MergeFrom(const MapPlayerMigrateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& target() const;
  inline ::slg::protocol::PositionDTO* mutable_target();
  inline ::slg::protocol::PositionDTO* release_target();
  inline void set_allocated_target(::slg::protocol::PositionDTO* target);

  // required bool useItem = 2;
  inline bool has_useitem() const;
  inline void clear_useitem();
  static const int kUseItemFieldNumber = 2;
  inline bool useitem() const;
  inline void set_useitem(bool value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapPlayerMigrateRequest)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_useitem();
  inline void clear_has_useitem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* target_;
  bool useitem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapPlayerMigrateRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapPlayerMigrateResponse : public ::google::protobuf::Message {
 public:
  MapPlayerMigrateResponse();
  virtual ~MapPlayerMigrateResponse();

  MapPlayerMigrateResponse(const MapPlayerMigrateResponse& from);

  inline MapPlayerMigrateResponse& operator=(const MapPlayerMigrateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPlayerMigrateResponse& default_instance();

  void Swap(MapPlayerMigrateResponse* other);

  // implements Message ----------------------------------------------

  MapPlayerMigrateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPlayerMigrateResponse& from);
  void MergeFrom(const MapPlayerMigrateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& target() const;
  inline ::slg::protocol::PositionDTO* mutable_target();
  inline ::slg::protocol::PositionDTO* release_target();
  inline void set_allocated_target(::slg::protocol::PositionDTO* target);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapPlayerMigrateResponse)
 private:
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* target_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapPlayerMigrateResponse* default_instance_;
};
// -------------------------------------------------------------------

class MapGridSearchRequest : public ::google::protobuf::Message {
 public:
  MapGridSearchRequest();
  virtual ~MapGridSearchRequest();

  MapGridSearchRequest(const MapGridSearchRequest& from);

  inline MapGridSearchRequest& operator=(const MapGridSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGridSearchRequest& default_instance();

  void Swap(MapGridSearchRequest* other);

  // implements Message ----------------------------------------------

  MapGridSearchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapGridSearchRequest& from);
  void MergeFrom(const MapGridSearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.MapGridSearchType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::slg::protocol::MapGridSearchType type() const;
  inline void set_type(::slg::protocol::MapGridSearchType value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapGridSearchRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapGridSearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapGridSearchResponse : public ::google::protobuf::Message {
 public:
  MapGridSearchResponse();
  virtual ~MapGridSearchResponse();

  MapGridSearchResponse(const MapGridSearchResponse& from);

  inline MapGridSearchResponse& operator=(const MapGridSearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGridSearchResponse& default_instance();

  void Swap(MapGridSearchResponse* other);

  // implements Message ----------------------------------------------

  MapGridSearchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapGridSearchResponse& from);
  void MergeFrom(const MapGridSearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& position() const;
  inline ::slg::protocol::PositionDTO* mutable_position();
  inline ::slg::protocol::PositionDTO* release_position();
  inline void set_allocated_position(::slg::protocol::PositionDTO* position);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapGridSearchResponse)
 private:
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapGridSearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteListRequest : public ::google::protobuf::Message {
 public:
  FaroriteListRequest();
  virtual ~FaroriteListRequest();

  FaroriteListRequest(const FaroriteListRequest& from);

  inline FaroriteListRequest& operator=(const FaroriteListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteListRequest& default_instance();

  void Swap(FaroriteListRequest* other);

  // implements Message ----------------------------------------------

  FaroriteListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteListRequest& from);
  void MergeFrom(const FaroriteListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteListRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteListRequest* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteListResponse : public ::google::protobuf::Message {
 public:
  FaroriteListResponse();
  virtual ~FaroriteListResponse();

  FaroriteListResponse(const FaroriteListResponse& from);

  inline FaroriteListResponse& operator=(const FaroriteListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteListResponse& default_instance();

  void Swap(FaroriteListResponse* other);

  // implements Message ----------------------------------------------

  FaroriteListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteListResponse& from);
  void MergeFrom(const FaroriteListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .slg.protocol.FaroriteDTO favoritelist = 3;
  inline int favoritelist_size() const;
  inline void clear_favoritelist();
  static const int kFavoritelistFieldNumber = 3;
  inline const ::slg::protocol::FaroriteDTO& favoritelist(int index) const;
  inline ::slg::protocol::FaroriteDTO* mutable_favoritelist(int index);
  inline ::slg::protocol::FaroriteDTO* add_favoritelist();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::FaroriteDTO >&
      favoritelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::FaroriteDTO >*
      mutable_favoritelist();

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteListResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::slg::protocol::FaroriteDTO > favoritelist_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteListResponse* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteRequest : public ::google::protobuf::Message {
 public:
  FaroriteRequest();
  virtual ~FaroriteRequest();

  FaroriteRequest(const FaroriteRequest& from);

  inline FaroriteRequest& operator=(const FaroriteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteRequest& default_instance();

  void Swap(FaroriteRequest* other);

  // implements Message ----------------------------------------------

  FaroriteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteRequest& from);
  void MergeFrom(const FaroriteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& position() const;
  inline ::slg::protocol::PositionDTO* mutable_position();
  inline ::slg::protocol::PositionDTO* release_position();
  inline void set_allocated_position(::slg::protocol::PositionDTO* position);

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteRequest)
 private:
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteRequest* default_instance_;
};
// -------------------------------------------------------------------

class FavoriteResponse : public ::google::protobuf::Message {
 public:
  FavoriteResponse();
  virtual ~FavoriteResponse();

  FavoriteResponse(const FavoriteResponse& from);

  inline FavoriteResponse& operator=(const FavoriteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FavoriteResponse& default_instance();

  void Swap(FavoriteResponse* other);

  // implements Message ----------------------------------------------

  FavoriteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FavoriteResponse& from);
  void MergeFrom(const FavoriteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.FaroriteDTO favorite = 2;
  inline bool has_favorite() const;
  inline void clear_favorite();
  static const int kFavoriteFieldNumber = 2;
  inline const ::slg::protocol::FaroriteDTO& favorite() const;
  inline ::slg::protocol::FaroriteDTO* mutable_favorite();
  inline ::slg::protocol::FaroriteDTO* release_favorite();
  inline void set_allocated_favorite(::slg::protocol::FaroriteDTO* favorite);

  // @@protoc_insertion_point(class_scope:slg.protocol.FavoriteResponse)
 private:
  inline void set_has_favorite();
  inline void clear_has_favorite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::FaroriteDTO* favorite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FavoriteResponse* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteRemoveRequest : public ::google::protobuf::Message {
 public:
  FaroriteRemoveRequest();
  virtual ~FaroriteRemoveRequest();

  FaroriteRemoveRequest(const FaroriteRemoveRequest& from);

  inline FaroriteRemoveRequest& operator=(const FaroriteRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteRemoveRequest& default_instance();

  void Swap(FaroriteRemoveRequest* other);

  // implements Message ----------------------------------------------

  FaroriteRemoveRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteRemoveRequest& from);
  void MergeFrom(const FaroriteRemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteRemoveRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteRemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class FaroriteRemoveResponse : public ::google::protobuf::Message {
 public:
  FaroriteRemoveResponse();
  virtual ~FaroriteRemoveResponse();

  FaroriteRemoveResponse(const FaroriteRemoveResponse& from);

  inline FaroriteRemoveResponse& operator=(const FaroriteRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaroriteRemoveResponse& default_instance();

  void Swap(FaroriteRemoveResponse* other);

  // implements Message ----------------------------------------------

  FaroriteRemoveResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaroriteRemoveResponse& from);
  void MergeFrom(const FaroriteRemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.FaroriteRemoveResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static FaroriteRemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class MapGridListPush : public ::google::protobuf::Message {
 public:
  MapGridListPush();
  virtual ~MapGridListPush();

  MapGridListPush(const MapGridListPush& from);

  inline MapGridListPush& operator=(const MapGridListPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGridListPush& default_instance();

  void Swap(MapGridListPush* other);

  // implements Message ----------------------------------------------

  MapGridListPush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapGridListPush& from);
  void MergeFrom(const MapGridListPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .slg.protocol.MapGridDTO mapGrids = 1;
  inline int mapgrids_size() const;
  inline void clear_mapgrids();
  static const int kMapGridsFieldNumber = 1;
  inline const ::slg::protocol::MapGridDTO& mapgrids(int index) const;
  inline ::slg::protocol::MapGridDTO* mutable_mapgrids(int index);
  inline ::slg::protocol::MapGridDTO* add_mapgrids();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::MapGridDTO >&
      mapgrids() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::MapGridDTO >*
      mutable_mapgrids();

  // @@protoc_insertion_point(class_scope:slg.protocol.MapGridListPush)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::slg::protocol::MapGridDTO > mapgrids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapGridListPush* default_instance_;
};
// -------------------------------------------------------------------

class MapGridRemovePush : public ::google::protobuf::Message {
 public:
  MapGridRemovePush();
  virtual ~MapGridRemovePush();

  MapGridRemovePush(const MapGridRemovePush& from);

  inline MapGridRemovePush& operator=(const MapGridRemovePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGridRemovePush& default_instance();

  void Swap(MapGridRemovePush* other);

  // implements Message ----------------------------------------------

  MapGridRemovePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapGridRemovePush& from);
  void MergeFrom(const MapGridRemovePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .slg.protocol.PositionDTO position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::slg::protocol::PositionDTO& position() const;
  inline ::slg::protocol::PositionDTO* mutable_position();
  inline ::slg::protocol::PositionDTO* release_position();
  inline void set_allocated_position(::slg::protocol::PositionDTO* position);

  // @@protoc_insertion_point(class_scope:slg.protocol.MapGridRemovePush)
 private:
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::slg::protocol::PositionDTO* position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapGridRemovePush* default_instance_;
};
// -------------------------------------------------------------------

class MonsterProgress : public ::google::protobuf::Message {
 public:
  MonsterProgress();
  virtual ~MonsterProgress();

  MonsterProgress(const MonsterProgress& from);

  inline MonsterProgress& operator=(const MonsterProgress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonsterProgress& default_instance();

  void Swap(MonsterProgress* other);

  // implements Message ----------------------------------------------

  MonsterProgress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonsterProgress& from);
  void MergeFrom(const MonsterProgress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 monsterTroopId = 2;
  inline bool has_monstertroopid() const;
  inline void clear_monstertroopid();
  static const int kMonsterTroopIdFieldNumber = 2;
  inline ::google::protobuf::int32 monstertroopid() const;
  inline void set_monstertroopid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:slg.protocol.MonsterProgress)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_monstertroopid();
  inline void clear_has_monstertroopid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 monstertroopid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MonsterProgress* default_instance_;
};
// -------------------------------------------------------------------

class MapMonsterProgressPush : public ::google::protobuf::Message {
 public:
  MapMonsterProgressPush();
  virtual ~MapMonsterProgressPush();

  MapMonsterProgressPush(const MapMonsterProgressPush& from);

  inline MapMonsterProgressPush& operator=(const MapMonsterProgressPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapMonsterProgressPush& default_instance();

  void Swap(MapMonsterProgressPush* other);

  // implements Message ----------------------------------------------

  MapMonsterProgressPush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapMonsterProgressPush& from);
  void MergeFrom(const MapMonsterProgressPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .slg.protocol.MonsterProgress progresses = 1;
  inline int progresses_size() const;
  inline void clear_progresses();
  static const int kProgressesFieldNumber = 1;
  inline const ::slg::protocol::MonsterProgress& progresses(int index) const;
  inline ::slg::protocol::MonsterProgress* mutable_progresses(int index);
  inline ::slg::protocol::MonsterProgress* add_progresses();
  inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::MonsterProgress >&
      progresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::MonsterProgress >*
      mutable_progresses();

  // @@protoc_insertion_point(class_scope:slg.protocol.MapMonsterProgressPush)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::slg::protocol::MonsterProgress > progresses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapMonsterProgressPush* default_instance_;
};
// ===================================================================


// ===================================================================

// MapGridDTO

// required .slg.protocol.PositionDTO location = 1;
inline bool MapGridDTO::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapGridDTO::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapGridDTO::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapGridDTO::clear_location() {
  if (location_ != NULL) location_->::slg::protocol::PositionDTO::Clear();
  clear_has_location();
}
inline const ::slg::protocol::PositionDTO& MapGridDTO::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::slg::protocol::PositionDTO* MapGridDTO::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::slg::protocol::PositionDTO;
  return location_;
}
inline ::slg::protocol::PositionDTO* MapGridDTO::release_location() {
  clear_has_location();
  ::slg::protocol::PositionDTO* temp = location_;
  location_ = NULL;
  return temp;
}
inline void MapGridDTO::set_allocated_location(::slg::protocol::PositionDTO* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
}

// required .slg.protocol.MapGridType type = 2;
inline bool MapGridDTO::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapGridDTO::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapGridDTO::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapGridDTO::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::slg::protocol::MapGridType MapGridDTO::type() const {
  return static_cast< ::slg::protocol::MapGridType >(type_);
}
inline void MapGridDTO::set_type(::slg::protocol::MapGridType value) {
  assert(::slg::protocol::MapGridType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes detail = 3;
inline bool MapGridDTO::has_detail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapGridDTO::set_has_detail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapGridDTO::clear_has_detail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapGridDTO::clear_detail() {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    detail_->clear();
  }
  clear_has_detail();
}
inline const ::std::string& MapGridDTO::detail() const {
  return *detail_;
}
inline void MapGridDTO::set_detail(const ::std::string& value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void MapGridDTO::set_detail(const char* value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void MapGridDTO::set_detail(const void* value, size_t size) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapGridDTO::mutable_detail() {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  return detail_;
}
inline ::std::string* MapGridDTO::release_detail() {
  clear_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_;
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapGridDTO::set_allocated_detail(::std::string* detail) {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    delete detail_;
  }
  if (detail) {
    set_has_detail();
    detail_ = detail;
  } else {
    clear_has_detail();
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 objId = 4;
inline bool MapGridDTO::has_objid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapGridDTO::set_has_objid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapGridDTO::clear_has_objid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapGridDTO::clear_objid() {
  objid_ = GOOGLE_LONGLONG(0);
  clear_has_objid();
}
inline ::google::protobuf::int64 MapGridDTO::objid() const {
  return objid_;
}
inline void MapGridDTO::set_objid(::google::protobuf::int64 value) {
  set_has_objid();
  objid_ = value;
}

// -------------------------------------------------------------------

// MapPlayerProfileDTO

// required int64 playerId = 1;
inline bool MapPlayerProfileDTO::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPlayerProfileDTO::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPlayerProfileDTO::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPlayerProfileDTO::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 MapPlayerProfileDTO::playerid() const {
  return playerid_;
}
inline void MapPlayerProfileDTO::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string nickName = 2;
inline bool MapPlayerProfileDTO::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPlayerProfileDTO::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPlayerProfileDTO::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPlayerProfileDTO::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& MapPlayerProfileDTO::nickname() const {
  return *nickname_;
}
inline void MapPlayerProfileDTO::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MapPlayerProfileDTO::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MapPlayerProfileDTO::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapPlayerProfileDTO::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* MapPlayerProfileDTO::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapPlayerProfileDTO::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string icon = 3;
inline bool MapPlayerProfileDTO::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPlayerProfileDTO::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapPlayerProfileDTO::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapPlayerProfileDTO::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& MapPlayerProfileDTO::icon() const {
  return *icon_;
}
inline void MapPlayerProfileDTO::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void MapPlayerProfileDTO::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void MapPlayerProfileDTO::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapPlayerProfileDTO::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* MapPlayerProfileDTO::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapPlayerProfileDTO::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 castleLevel = 4;
inline bool MapPlayerProfileDTO::has_castlelevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapPlayerProfileDTO::set_has_castlelevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapPlayerProfileDTO::clear_has_castlelevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapPlayerProfileDTO::clear_castlelevel() {
  castlelevel_ = 0;
  clear_has_castlelevel();
}
inline ::google::protobuf::int32 MapPlayerProfileDTO::castlelevel() const {
  return castlelevel_;
}
inline void MapPlayerProfileDTO::set_castlelevel(::google::protobuf::int32 value) {
  set_has_castlelevel();
  castlelevel_ = value;
}

// -------------------------------------------------------------------

// MapResourceOccupierDTO

// required .slg.protocol.MapPlayerProfileDTO player = 1;
inline bool MapResourceOccupierDTO::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapResourceOccupierDTO::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapResourceOccupierDTO::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapResourceOccupierDTO::clear_player() {
  if (player_ != NULL) player_->::slg::protocol::MapPlayerProfileDTO::Clear();
  clear_has_player();
}
inline const ::slg::protocol::MapPlayerProfileDTO& MapResourceOccupierDTO::player() const {
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::slg::protocol::MapPlayerProfileDTO* MapResourceOccupierDTO::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::slg::protocol::MapPlayerProfileDTO;
  return player_;
}
inline ::slg::protocol::MapPlayerProfileDTO* MapResourceOccupierDTO::release_player() {
  clear_has_player();
  ::slg::protocol::MapPlayerProfileDTO* temp = player_;
  player_ = NULL;
  return temp;
}
inline void MapResourceOccupierDTO::set_allocated_player(::slg::protocol::MapPlayerProfileDTO* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
}

// repeated .slg.protocol.LevelSoldierDTO soldiers = 2;
inline int MapResourceOccupierDTO::soldiers_size() const {
  return soldiers_.size();
}
inline void MapResourceOccupierDTO::clear_soldiers() {
  soldiers_.Clear();
}
inline const ::slg::protocol::LevelSoldierDTO& MapResourceOccupierDTO::soldiers(int index) const {
  return soldiers_.Get(index);
}
inline ::slg::protocol::LevelSoldierDTO* MapResourceOccupierDTO::mutable_soldiers(int index) {
  return soldiers_.Mutable(index);
}
inline ::slg::protocol::LevelSoldierDTO* MapResourceOccupierDTO::add_soldiers() {
  return soldiers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::LevelSoldierDTO >&
MapResourceOccupierDTO::soldiers() const {
  return soldiers_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::LevelSoldierDTO >*
MapResourceOccupierDTO::mutable_soldiers() {
  return &soldiers_;
}

// required int32 gatherTime = 4;
inline bool MapResourceOccupierDTO::has_gathertime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapResourceOccupierDTO::set_has_gathertime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapResourceOccupierDTO::clear_has_gathertime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapResourceOccupierDTO::clear_gathertime() {
  gathertime_ = 0;
  clear_has_gathertime();
}
inline ::google::protobuf::int32 MapResourceOccupierDTO::gathertime() const {
  return gathertime_;
}
inline void MapResourceOccupierDTO::set_gathertime(::google::protobuf::int32 value) {
  set_has_gathertime();
  gathertime_ = value;
}

// required int32 gatherNum = 5;
inline bool MapResourceOccupierDTO::has_gathernum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapResourceOccupierDTO::set_has_gathernum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapResourceOccupierDTO::clear_has_gathernum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapResourceOccupierDTO::clear_gathernum() {
  gathernum_ = 0;
  clear_has_gathernum();
}
inline ::google::protobuf::int32 MapResourceOccupierDTO::gathernum() const {
  return gathernum_;
}
inline void MapResourceOccupierDTO::set_gathernum(::google::protobuf::int32 value) {
  set_has_gathernum();
  gathernum_ = value;
}

// required int32 gatherRate = 6;
inline bool MapResourceOccupierDTO::has_gatherrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapResourceOccupierDTO::set_has_gatherrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapResourceOccupierDTO::clear_has_gatherrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapResourceOccupierDTO::clear_gatherrate() {
  gatherrate_ = 0;
  clear_has_gatherrate();
}
inline ::google::protobuf::int32 MapResourceOccupierDTO::gatherrate() const {
  return gatherrate_;
}
inline void MapResourceOccupierDTO::set_gatherrate(::google::protobuf::int32 value) {
  set_has_gatherrate();
  gatherrate_ = value;
}

// optional int32 addRate = 7;
inline bool MapResourceOccupierDTO::has_addrate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapResourceOccupierDTO::set_has_addrate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapResourceOccupierDTO::clear_has_addrate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapResourceOccupierDTO::clear_addrate() {
  addrate_ = 0;
  clear_has_addrate();
}
inline ::google::protobuf::int32 MapResourceOccupierDTO::addrate() const {
  return addrate_;
}
inline void MapResourceOccupierDTO::set_addrate(::google::protobuf::int32 value) {
  set_has_addrate();
  addrate_ = value;
}

// optional int64 marchid = 8;
inline bool MapResourceOccupierDTO::has_marchid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapResourceOccupierDTO::set_has_marchid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapResourceOccupierDTO::clear_has_marchid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapResourceOccupierDTO::clear_marchid() {
  marchid_ = GOOGLE_LONGLONG(0);
  clear_has_marchid();
}
inline ::google::protobuf::int64 MapResourceOccupierDTO::marchid() const {
  return marchid_;
}
inline void MapResourceOccupierDTO::set_marchid(::google::protobuf::int64 value) {
  set_has_marchid();
  marchid_ = value;
}

// -------------------------------------------------------------------

// MapPlayerGridDTO

// required .slg.protocol.MapPlayerProfileDTO player = 1;
inline bool MapPlayerGridDTO::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPlayerGridDTO::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPlayerGridDTO::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPlayerGridDTO::clear_player() {
  if (player_ != NULL) player_->::slg::protocol::MapPlayerProfileDTO::Clear();
  clear_has_player();
}
inline const ::slg::protocol::MapPlayerProfileDTO& MapPlayerGridDTO::player() const {
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::slg::protocol::MapPlayerProfileDTO* MapPlayerGridDTO::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::slg::protocol::MapPlayerProfileDTO;
  return player_;
}
inline ::slg::protocol::MapPlayerProfileDTO* MapPlayerGridDTO::release_player() {
  clear_has_player();
  ::slg::protocol::MapPlayerProfileDTO* temp = player_;
  player_ = NULL;
  return temp;
}
inline void MapPlayerGridDTO::set_allocated_player(::slg::protocol::MapPlayerProfileDTO* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
}

// -------------------------------------------------------------------

// MapResourceGridDTO

// required int32 type = 1;
inline bool MapResourceGridDTO::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapResourceGridDTO::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapResourceGridDTO::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapResourceGridDTO::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MapResourceGridDTO::type() const {
  return type_;
}
inline void MapResourceGridDTO::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 level = 2;
inline bool MapResourceGridDTO::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapResourceGridDTO::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapResourceGridDTO::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapResourceGridDTO::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MapResourceGridDTO::level() const {
  return level_;
}
inline void MapResourceGridDTO::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 remain = 3;
inline bool MapResourceGridDTO::has_remain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapResourceGridDTO::set_has_remain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapResourceGridDTO::clear_has_remain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapResourceGridDTO::clear_remain() {
  remain_ = 0;
  clear_has_remain();
}
inline ::google::protobuf::int32 MapResourceGridDTO::remain() const {
  return remain_;
}
inline void MapResourceGridDTO::set_remain(::google::protobuf::int32 value) {
  set_has_remain();
  remain_ = value;
}

// optional .slg.protocol.MapResourceOccupierDTO occupier = 9;
inline bool MapResourceGridDTO::has_occupier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapResourceGridDTO::set_has_occupier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapResourceGridDTO::clear_has_occupier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapResourceGridDTO::clear_occupier() {
  if (occupier_ != NULL) occupier_->::slg::protocol::MapResourceOccupierDTO::Clear();
  clear_has_occupier();
}
inline const ::slg::protocol::MapResourceOccupierDTO& MapResourceGridDTO::occupier() const {
  return occupier_ != NULL ? *occupier_ : *default_instance_->occupier_;
}
inline ::slg::protocol::MapResourceOccupierDTO* MapResourceGridDTO::mutable_occupier() {
  set_has_occupier();
  if (occupier_ == NULL) occupier_ = new ::slg::protocol::MapResourceOccupierDTO;
  return occupier_;
}
inline ::slg::protocol::MapResourceOccupierDTO* MapResourceGridDTO::release_occupier() {
  clear_has_occupier();
  ::slg::protocol::MapResourceOccupierDTO* temp = occupier_;
  occupier_ = NULL;
  return temp;
}
inline void MapResourceGridDTO::set_allocated_occupier(::slg::protocol::MapResourceOccupierDTO* occupier) {
  delete occupier_;
  occupier_ = occupier;
  if (occupier) {
    set_has_occupier();
  } else {
    clear_has_occupier();
  }
}

// -------------------------------------------------------------------

// MapMonsterGridDTO

// required int32 configId = 1;
inline bool MapMonsterGridDTO::has_configid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapMonsterGridDTO::set_has_configid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapMonsterGridDTO::clear_has_configid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapMonsterGridDTO::clear_configid() {
  configid_ = 0;
  clear_has_configid();
}
inline ::google::protobuf::int32 MapMonsterGridDTO::configid() const {
  return configid_;
}
inline void MapMonsterGridDTO::set_configid(::google::protobuf::int32 value) {
  set_has_configid();
  configid_ = value;
}

// -------------------------------------------------------------------

// MapObstacleGridDTO

// required int32 configId = 1;
inline bool MapObstacleGridDTO::has_configid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapObstacleGridDTO::set_has_configid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapObstacleGridDTO::clear_has_configid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapObstacleGridDTO::clear_configid() {
  configid_ = 0;
  clear_has_configid();
}
inline ::google::protobuf::int32 MapObstacleGridDTO::configid() const {
  return configid_;
}
inline void MapObstacleGridDTO::set_configid(::google::protobuf::int32 value) {
  set_has_configid();
  configid_ = value;
}

// -------------------------------------------------------------------

// FaroriteDTO

// required .slg.protocol.MapGridType type = 1;
inline bool FaroriteDTO::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteDTO::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteDTO::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteDTO::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::slg::protocol::MapGridType FaroriteDTO::type() const {
  return static_cast< ::slg::protocol::MapGridType >(type_);
}
inline void FaroriteDTO::set_type(::slg::protocol::MapGridType value) {
  assert(::slg::protocol::MapGridType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .slg.protocol.PositionDTO location = 2;
inline bool FaroriteDTO::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaroriteDTO::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaroriteDTO::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaroriteDTO::clear_location() {
  if (location_ != NULL) location_->::slg::protocol::PositionDTO::Clear();
  clear_has_location();
}
inline const ::slg::protocol::PositionDTO& FaroriteDTO::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::slg::protocol::PositionDTO* FaroriteDTO::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::slg::protocol::PositionDTO;
  return location_;
}
inline ::slg::protocol::PositionDTO* FaroriteDTO::release_location() {
  clear_has_location();
  ::slg::protocol::PositionDTO* temp = location_;
  location_ = NULL;
  return temp;
}
inline void FaroriteDTO::set_allocated_location(::slg::protocol::PositionDTO* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
}

// optional int32 subtype = 3;
inline bool FaroriteDTO::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaroriteDTO::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaroriteDTO::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaroriteDTO::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::google::protobuf::int32 FaroriteDTO::subtype() const {
  return subtype_;
}
inline void FaroriteDTO::set_subtype(::google::protobuf::int32 value) {
  set_has_subtype();
  subtype_ = value;
}

// optional int32 level = 4;
inline bool FaroriteDTO::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaroriteDTO::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FaroriteDTO::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FaroriteDTO::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 FaroriteDTO::level() const {
  return level_;
}
inline void FaroriteDTO::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string icon = 5;
inline bool FaroriteDTO::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FaroriteDTO::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FaroriteDTO::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FaroriteDTO::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& FaroriteDTO::icon() const {
  return *icon_;
}
inline void FaroriteDTO::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void FaroriteDTO::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void FaroriteDTO::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FaroriteDTO::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* FaroriteDTO::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FaroriteDTO::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playernme = 6;
inline bool FaroriteDTO::has_playernme() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FaroriteDTO::set_has_playernme() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FaroriteDTO::clear_has_playernme() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FaroriteDTO::clear_playernme() {
  if (playernme_ != &::google::protobuf::internal::kEmptyString) {
    playernme_->clear();
  }
  clear_has_playernme();
}
inline const ::std::string& FaroriteDTO::playernme() const {
  return *playernme_;
}
inline void FaroriteDTO::set_playernme(const ::std::string& value) {
  set_has_playernme();
  if (playernme_ == &::google::protobuf::internal::kEmptyString) {
    playernme_ = new ::std::string;
  }
  playernme_->assign(value);
}
inline void FaroriteDTO::set_playernme(const char* value) {
  set_has_playernme();
  if (playernme_ == &::google::protobuf::internal::kEmptyString) {
    playernme_ = new ::std::string;
  }
  playernme_->assign(value);
}
inline void FaroriteDTO::set_playernme(const char* value, size_t size) {
  set_has_playernme();
  if (playernme_ == &::google::protobuf::internal::kEmptyString) {
    playernme_ = new ::std::string;
  }
  playernme_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FaroriteDTO::mutable_playernme() {
  set_has_playernme();
  if (playernme_ == &::google::protobuf::internal::kEmptyString) {
    playernme_ = new ::std::string;
  }
  return playernme_;
}
inline ::std::string* FaroriteDTO::release_playernme() {
  clear_has_playernme();
  if (playernme_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playernme_;
    playernme_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FaroriteDTO::set_allocated_playernme(::std::string* playernme) {
  if (playernme_ != &::google::protobuf::internal::kEmptyString) {
    delete playernme_;
  }
  if (playernme) {
    set_has_playernme();
    playernme_ = playernme;
  } else {
    clear_has_playernme();
    playernme_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 resourceNum = 7;
inline bool FaroriteDTO::has_resourcenum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FaroriteDTO::set_has_resourcenum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FaroriteDTO::clear_has_resourcenum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FaroriteDTO::clear_resourcenum() {
  resourcenum_ = 0;
  clear_has_resourcenum();
}
inline ::google::protobuf::int32 FaroriteDTO::resourcenum() const {
  return resourcenum_;
}
inline void FaroriteDTO::set_resourcenum(::google::protobuf::int32 value) {
  set_has_resourcenum();
  resourcenum_ = value;
}

// optional string alliancename = 8;
inline bool FaroriteDTO::has_alliancename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FaroriteDTO::set_has_alliancename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FaroriteDTO::clear_has_alliancename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FaroriteDTO::clear_alliancename() {
  if (alliancename_ != &::google::protobuf::internal::kEmptyString) {
    alliancename_->clear();
  }
  clear_has_alliancename();
}
inline const ::std::string& FaroriteDTO::alliancename() const {
  return *alliancename_;
}
inline void FaroriteDTO::set_alliancename(const ::std::string& value) {
  set_has_alliancename();
  if (alliancename_ == &::google::protobuf::internal::kEmptyString) {
    alliancename_ = new ::std::string;
  }
  alliancename_->assign(value);
}
inline void FaroriteDTO::set_alliancename(const char* value) {
  set_has_alliancename();
  if (alliancename_ == &::google::protobuf::internal::kEmptyString) {
    alliancename_ = new ::std::string;
  }
  alliancename_->assign(value);
}
inline void FaroriteDTO::set_alliancename(const char* value, size_t size) {
  set_has_alliancename();
  if (alliancename_ == &::google::protobuf::internal::kEmptyString) {
    alliancename_ = new ::std::string;
  }
  alliancename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FaroriteDTO::mutable_alliancename() {
  set_has_alliancename();
  if (alliancename_ == &::google::protobuf::internal::kEmptyString) {
    alliancename_ = new ::std::string;
  }
  return alliancename_;
}
inline ::std::string* FaroriteDTO::release_alliancename() {
  clear_has_alliancename();
  if (alliancename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alliancename_;
    alliancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FaroriteDTO::set_allocated_alliancename(::std::string* alliancename) {
  if (alliancename_ != &::google::protobuf::internal::kEmptyString) {
    delete alliancename_;
  }
  if (alliancename) {
    set_has_alliancename();
    alliancename_ = alliancename;
  } else {
    clear_has_alliancename();
    alliancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MapQueryRequest

// required .slg.protocol.PositionDTO start = 1;
inline bool MapQueryRequest::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapQueryRequest::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapQueryRequest::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapQueryRequest::clear_start() {
  if (start_ != NULL) start_->::slg::protocol::PositionDTO::Clear();
  clear_has_start();
}
inline const ::slg::protocol::PositionDTO& MapQueryRequest::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::slg::protocol::PositionDTO;
  return start_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::release_start() {
  clear_has_start();
  ::slg::protocol::PositionDTO* temp = start_;
  start_ = NULL;
  return temp;
}
inline void MapQueryRequest::set_allocated_start(::slg::protocol::PositionDTO* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// required .slg.protocol.PositionDTO end = 2;
inline bool MapQueryRequest::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapQueryRequest::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapQueryRequest::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapQueryRequest::clear_end() {
  if (end_ != NULL) end_->::slg::protocol::PositionDTO::Clear();
  clear_has_end();
}
inline const ::slg::protocol::PositionDTO& MapQueryRequest::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::slg::protocol::PositionDTO;
  return end_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::release_end() {
  clear_has_end();
  ::slg::protocol::PositionDTO* temp = end_;
  end_ = NULL;
  return temp;
}
inline void MapQueryRequest::set_allocated_end(::slg::protocol::PositionDTO* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// required .slg.protocol.PositionDTO center = 3;
inline bool MapQueryRequest::has_center() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapQueryRequest::set_has_center() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapQueryRequest::clear_has_center() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapQueryRequest::clear_center() {
  if (center_ != NULL) center_->::slg::protocol::PositionDTO::Clear();
  clear_has_center();
}
inline const ::slg::protocol::PositionDTO& MapQueryRequest::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::slg::protocol::PositionDTO;
  return center_;
}
inline ::slg::protocol::PositionDTO* MapQueryRequest::release_center() {
  clear_has_center();
  ::slg::protocol::PositionDTO* temp = center_;
  center_ = NULL;
  return temp;
}
inline void MapQueryRequest::set_allocated_center(::slg::protocol::PositionDTO* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// -------------------------------------------------------------------

// MapPlayerMigrateRequest

// required .slg.protocol.PositionDTO target = 1;
inline bool MapPlayerMigrateRequest::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPlayerMigrateRequest::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPlayerMigrateRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPlayerMigrateRequest::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::PositionDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::PositionDTO& MapPlayerMigrateRequest::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::PositionDTO* MapPlayerMigrateRequest::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::PositionDTO;
  return target_;
}
inline ::slg::protocol::PositionDTO* MapPlayerMigrateRequest::release_target() {
  clear_has_target();
  ::slg::protocol::PositionDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void MapPlayerMigrateRequest::set_allocated_target(::slg::protocol::PositionDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// required bool useItem = 2;
inline bool MapPlayerMigrateRequest::has_useitem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPlayerMigrateRequest::set_has_useitem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPlayerMigrateRequest::clear_has_useitem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPlayerMigrateRequest::clear_useitem() {
  useitem_ = false;
  clear_has_useitem();
}
inline bool MapPlayerMigrateRequest::useitem() const {
  return useitem_;
}
inline void MapPlayerMigrateRequest::set_useitem(bool value) {
  set_has_useitem();
  useitem_ = value;
}

// -------------------------------------------------------------------

// MapPlayerMigrateResponse

// required .slg.protocol.PositionDTO target = 1;
inline bool MapPlayerMigrateResponse::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPlayerMigrateResponse::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPlayerMigrateResponse::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPlayerMigrateResponse::clear_target() {
  if (target_ != NULL) target_->::slg::protocol::PositionDTO::Clear();
  clear_has_target();
}
inline const ::slg::protocol::PositionDTO& MapPlayerMigrateResponse::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::slg::protocol::PositionDTO* MapPlayerMigrateResponse::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::slg::protocol::PositionDTO;
  return target_;
}
inline ::slg::protocol::PositionDTO* MapPlayerMigrateResponse::release_target() {
  clear_has_target();
  ::slg::protocol::PositionDTO* temp = target_;
  target_ = NULL;
  return temp;
}
inline void MapPlayerMigrateResponse::set_allocated_target(::slg::protocol::PositionDTO* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// MapGridSearchRequest

// required .slg.protocol.MapGridSearchType type = 1;
inline bool MapGridSearchRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapGridSearchRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapGridSearchRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapGridSearchRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::slg::protocol::MapGridSearchType MapGridSearchRequest::type() const {
  return static_cast< ::slg::protocol::MapGridSearchType >(type_);
}
inline void MapGridSearchRequest::set_type(::slg::protocol::MapGridSearchType value) {
  assert(::slg::protocol::MapGridSearchType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 level = 2;
inline bool MapGridSearchRequest::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapGridSearchRequest::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapGridSearchRequest::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapGridSearchRequest::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MapGridSearchRequest::level() const {
  return level_;
}
inline void MapGridSearchRequest::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// MapGridSearchResponse

// required .slg.protocol.PositionDTO position = 1;
inline bool MapGridSearchResponse::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapGridSearchResponse::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapGridSearchResponse::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapGridSearchResponse::clear_position() {
  if (position_ != NULL) position_->::slg::protocol::PositionDTO::Clear();
  clear_has_position();
}
inline const ::slg::protocol::PositionDTO& MapGridSearchResponse::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::slg::protocol::PositionDTO* MapGridSearchResponse::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::slg::protocol::PositionDTO;
  return position_;
}
inline ::slg::protocol::PositionDTO* MapGridSearchResponse::release_position() {
  clear_has_position();
  ::slg::protocol::PositionDTO* temp = position_;
  position_ = NULL;
  return temp;
}
inline void MapGridSearchResponse::set_allocated_position(::slg::protocol::PositionDTO* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// -------------------------------------------------------------------

// FaroriteListRequest

// required int32 type = 1;
inline bool FaroriteListRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteListRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteListRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteListRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FaroriteListRequest::type() const {
  return type_;
}
inline void FaroriteListRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// FaroriteListResponse

// required int32 type = 1;
inline bool FaroriteListResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteListResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteListResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteListResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FaroriteListResponse::type() const {
  return type_;
}
inline void FaroriteListResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .slg.protocol.FaroriteDTO favoritelist = 3;
inline int FaroriteListResponse::favoritelist_size() const {
  return favoritelist_.size();
}
inline void FaroriteListResponse::clear_favoritelist() {
  favoritelist_.Clear();
}
inline const ::slg::protocol::FaroriteDTO& FaroriteListResponse::favoritelist(int index) const {
  return favoritelist_.Get(index);
}
inline ::slg::protocol::FaroriteDTO* FaroriteListResponse::mutable_favoritelist(int index) {
  return favoritelist_.Mutable(index);
}
inline ::slg::protocol::FaroriteDTO* FaroriteListResponse::add_favoritelist() {
  return favoritelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::FaroriteDTO >&
FaroriteListResponse::favoritelist() const {
  return favoritelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::FaroriteDTO >*
FaroriteListResponse::mutable_favoritelist() {
  return &favoritelist_;
}

// -------------------------------------------------------------------

// FaroriteRequest

// required .slg.protocol.PositionDTO position = 1;
inline bool FaroriteRequest::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteRequest::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteRequest::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteRequest::clear_position() {
  if (position_ != NULL) position_->::slg::protocol::PositionDTO::Clear();
  clear_has_position();
}
inline const ::slg::protocol::PositionDTO& FaroriteRequest::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::slg::protocol::PositionDTO* FaroriteRequest::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::slg::protocol::PositionDTO;
  return position_;
}
inline ::slg::protocol::PositionDTO* FaroriteRequest::release_position() {
  clear_has_position();
  ::slg::protocol::PositionDTO* temp = position_;
  position_ = NULL;
  return temp;
}
inline void FaroriteRequest::set_allocated_position(::slg::protocol::PositionDTO* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// -------------------------------------------------------------------

// FavoriteResponse

// required .slg.protocol.FaroriteDTO favorite = 2;
inline bool FavoriteResponse::has_favorite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FavoriteResponse::set_has_favorite() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FavoriteResponse::clear_has_favorite() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FavoriteResponse::clear_favorite() {
  if (favorite_ != NULL) favorite_->::slg::protocol::FaroriteDTO::Clear();
  clear_has_favorite();
}
inline const ::slg::protocol::FaroriteDTO& FavoriteResponse::favorite() const {
  return favorite_ != NULL ? *favorite_ : *default_instance_->favorite_;
}
inline ::slg::protocol::FaroriteDTO* FavoriteResponse::mutable_favorite() {
  set_has_favorite();
  if (favorite_ == NULL) favorite_ = new ::slg::protocol::FaroriteDTO;
  return favorite_;
}
inline ::slg::protocol::FaroriteDTO* FavoriteResponse::release_favorite() {
  clear_has_favorite();
  ::slg::protocol::FaroriteDTO* temp = favorite_;
  favorite_ = NULL;
  return temp;
}
inline void FavoriteResponse::set_allocated_favorite(::slg::protocol::FaroriteDTO* favorite) {
  delete favorite_;
  favorite_ = favorite;
  if (favorite) {
    set_has_favorite();
  } else {
    clear_has_favorite();
  }
}

// -------------------------------------------------------------------

// FaroriteRemoveRequest

// required int32 type = 1;
inline bool FaroriteRemoveRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteRemoveRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteRemoveRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteRemoveRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FaroriteRemoveRequest::type() const {
  return type_;
}
inline void FaroriteRemoveRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 index = 2;
inline bool FaroriteRemoveRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaroriteRemoveRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaroriteRemoveRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaroriteRemoveRequest::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 FaroriteRemoveRequest::index() const {
  return index_;
}
inline void FaroriteRemoveRequest::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// FaroriteRemoveResponse

// required int32 type = 1;
inline bool FaroriteRemoveResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaroriteRemoveResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaroriteRemoveResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaroriteRemoveResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FaroriteRemoveResponse::type() const {
  return type_;
}
inline void FaroriteRemoveResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 index = 2;
inline bool FaroriteRemoveResponse::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaroriteRemoveResponse::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaroriteRemoveResponse::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaroriteRemoveResponse::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 FaroriteRemoveResponse::index() const {
  return index_;
}
inline void FaroriteRemoveResponse::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// MapGridListPush

// repeated .slg.protocol.MapGridDTO mapGrids = 1;
inline int MapGridListPush::mapgrids_size() const {
  return mapgrids_.size();
}
inline void MapGridListPush::clear_mapgrids() {
  mapgrids_.Clear();
}
inline const ::slg::protocol::MapGridDTO& MapGridListPush::mapgrids(int index) const {
  return mapgrids_.Get(index);
}
inline ::slg::protocol::MapGridDTO* MapGridListPush::mutable_mapgrids(int index) {
  return mapgrids_.Mutable(index);
}
inline ::slg::protocol::MapGridDTO* MapGridListPush::add_mapgrids() {
  return mapgrids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::MapGridDTO >&
MapGridListPush::mapgrids() const {
  return mapgrids_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::MapGridDTO >*
MapGridListPush::mutable_mapgrids() {
  return &mapgrids_;
}

// -------------------------------------------------------------------

// MapGridRemovePush

// required .slg.protocol.PositionDTO position = 1;
inline bool MapGridRemovePush::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapGridRemovePush::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapGridRemovePush::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapGridRemovePush::clear_position() {
  if (position_ != NULL) position_->::slg::protocol::PositionDTO::Clear();
  clear_has_position();
}
inline const ::slg::protocol::PositionDTO& MapGridRemovePush::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::slg::protocol::PositionDTO* MapGridRemovePush::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::slg::protocol::PositionDTO;
  return position_;
}
inline ::slg::protocol::PositionDTO* MapGridRemovePush::release_position() {
  clear_has_position();
  ::slg::protocol::PositionDTO* temp = position_;
  position_ = NULL;
  return temp;
}
inline void MapGridRemovePush::set_allocated_position(::slg::protocol::PositionDTO* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// -------------------------------------------------------------------

// MonsterProgress

// required int32 type = 1;
inline bool MonsterProgress::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonsterProgress::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonsterProgress::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonsterProgress::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MonsterProgress::type() const {
  return type_;
}
inline void MonsterProgress::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 monsterTroopId = 2;
inline bool MonsterProgress::has_monstertroopid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonsterProgress::set_has_monstertroopid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonsterProgress::clear_has_monstertroopid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonsterProgress::clear_monstertroopid() {
  monstertroopid_ = 0;
  clear_has_monstertroopid();
}
inline ::google::protobuf::int32 MonsterProgress::monstertroopid() const {
  return monstertroopid_;
}
inline void MonsterProgress::set_monstertroopid(::google::protobuf::int32 value) {
  set_has_monstertroopid();
  monstertroopid_ = value;
}

// -------------------------------------------------------------------

// MapMonsterProgressPush

// repeated .slg.protocol.MonsterProgress progresses = 1;
inline int MapMonsterProgressPush::progresses_size() const {
  return progresses_.size();
}
inline void MapMonsterProgressPush::clear_progresses() {
  progresses_.Clear();
}
inline const ::slg::protocol::MonsterProgress& MapMonsterProgressPush::progresses(int index) const {
  return progresses_.Get(index);
}
inline ::slg::protocol::MonsterProgress* MapMonsterProgressPush::mutable_progresses(int index) {
  return progresses_.Mutable(index);
}
inline ::slg::protocol::MonsterProgress* MapMonsterProgressPush::add_progresses() {
  return progresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::slg::protocol::MonsterProgress >&
MapMonsterProgressPush::progresses() const {
  return progresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::slg::protocol::MonsterProgress >*
MapMonsterProgressPush::mutable_progresses() {
  return &progresses_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace slg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::MapGridType>() {
  return ::slg::protocol::MapGridType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::MapCommandId>() {
  return ::slg::protocol::MapCommandId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::MapGridSearchType>() {
  return ::slg::protocol::MapGridSearchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slg::protocol::MapPushId>() {
  return ::slg::protocol::MapPushId_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_2eproto__INCLUDED
