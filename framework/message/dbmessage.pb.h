// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbmessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dbmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dbmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dbmessage_2eproto;
class CMsgExecuteSqlRequest;
class CMsgExecuteSqlRequestDefaultTypeInternal;
extern CMsgExecuteSqlRequestDefaultTypeInternal _CMsgExecuteSqlRequest_default_instance_;
class CMsgExecuteSqlResponse;
class CMsgExecuteSqlResponseDefaultTypeInternal;
extern CMsgExecuteSqlResponseDefaultTypeInternal _CMsgExecuteSqlResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgExecuteSqlRequest* Arena::CreateMaybeMessage<::CMsgExecuteSqlRequest>(Arena*);
template<> ::CMsgExecuteSqlResponse* Arena::CreateMaybeMessage<::CMsgExecuteSqlResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgExecuteSqlRequest_Msg : int {
  CMsgExecuteSqlRequest_Msg_MsgID = 10001
};
bool CMsgExecuteSqlRequest_Msg_IsValid(int value);
constexpr CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MIN = CMsgExecuteSqlRequest_Msg_MsgID;
constexpr CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MAX = CMsgExecuteSqlRequest_Msg_MsgID;
constexpr int CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlRequest_Msg_Msg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgExecuteSqlRequest_Msg_descriptor();
template<typename T>
inline const std::string& CMsgExecuteSqlRequest_Msg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgExecuteSqlRequest_Msg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgExecuteSqlRequest_Msg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgExecuteSqlRequest_Msg_descriptor(), enum_t_value);
}
inline bool CMsgExecuteSqlRequest_Msg_Parse(
    const std::string& name, CMsgExecuteSqlRequest_Msg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgExecuteSqlRequest_Msg>(
    CMsgExecuteSqlRequest_Msg_descriptor(), name, value);
}
enum CMsgExecuteSqlResponse_Msg : int {
  CMsgExecuteSqlResponse_Msg_MsgID = 10002
};
bool CMsgExecuteSqlResponse_Msg_IsValid(int value);
constexpr CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MIN = CMsgExecuteSqlResponse_Msg_MsgID;
constexpr CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MAX = CMsgExecuteSqlResponse_Msg_MsgID;
constexpr int CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlResponse_Msg_Msg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgExecuteSqlResponse_Msg_descriptor();
template<typename T>
inline const std::string& CMsgExecuteSqlResponse_Msg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgExecuteSqlResponse_Msg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgExecuteSqlResponse_Msg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgExecuteSqlResponse_Msg_descriptor(), enum_t_value);
}
inline bool CMsgExecuteSqlResponse_Msg_Parse(
    const std::string& name, CMsgExecuteSqlResponse_Msg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgExecuteSqlResponse_Msg>(
    CMsgExecuteSqlResponse_Msg_descriptor(), name, value);
}
enum SQLTYPE : int {
  SELECT = 1,
  INSERT = 2,
  UPDATE = 3,
  DELETE = 4,
  CALL = 5
};
bool SQLTYPE_IsValid(int value);
constexpr SQLTYPE SQLTYPE_MIN = SELECT;
constexpr SQLTYPE SQLTYPE_MAX = CALL;
constexpr int SQLTYPE_ARRAYSIZE = SQLTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SQLTYPE_descriptor();
template<typename T>
inline const std::string& SQLTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SQLTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SQLTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SQLTYPE_descriptor(), enum_t_value);
}
inline bool SQLTYPE_Parse(
    const std::string& name, SQLTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SQLTYPE>(
    SQLTYPE_descriptor(), name, value);
}
enum CALLBACK : int {
  MUSTCALLBACK = 1,
  NOTCALLBACK = 2
};
bool CALLBACK_IsValid(int value);
constexpr CALLBACK CALLBACK_MIN = MUSTCALLBACK;
constexpr CALLBACK CALLBACK_MAX = NOTCALLBACK;
constexpr int CALLBACK_ARRAYSIZE = CALLBACK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CALLBACK_descriptor();
template<typename T>
inline const std::string& CALLBACK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CALLBACK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CALLBACK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CALLBACK_descriptor(), enum_t_value);
}
inline bool CALLBACK_Parse(
    const std::string& name, CALLBACK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CALLBACK>(
    CALLBACK_descriptor(), name, value);
}
enum BLOB : int {
  HASBLOB = 1,
  NONEBLOB = 2
};
bool BLOB_IsValid(int value);
constexpr BLOB BLOB_MIN = HASBLOB;
constexpr BLOB BLOB_MAX = NONEBLOB;
constexpr int BLOB_ARRAYSIZE = BLOB_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BLOB_descriptor();
template<typename T>
inline const std::string& BLOB_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BLOB>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BLOB_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BLOB_descriptor(), enum_t_value);
}
inline bool BLOB_Parse(
    const std::string& name, BLOB* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BLOB>(
    BLOB_descriptor(), name, value);
}
// ===================================================================

class CMsgExecuteSqlRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgExecuteSqlRequest) */ {
 public:
  CMsgExecuteSqlRequest();
  virtual ~CMsgExecuteSqlRequest();

  CMsgExecuteSqlRequest(const CMsgExecuteSqlRequest& from);
  CMsgExecuteSqlRequest(CMsgExecuteSqlRequest&& from) noexcept
    : CMsgExecuteSqlRequest() {
    *this = ::std::move(from);
  }

  inline CMsgExecuteSqlRequest& operator=(const CMsgExecuteSqlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgExecuteSqlRequest& operator=(CMsgExecuteSqlRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CMsgExecuteSqlRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgExecuteSqlRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgExecuteSqlRequest*>(
               &_CMsgExecuteSqlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgExecuteSqlRequest* other);
  friend void swap(CMsgExecuteSqlRequest& a, CMsgExecuteSqlRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgExecuteSqlRequest* New() const final {
    return CreateMaybeMessage<CMsgExecuteSqlRequest>(nullptr);
  }

  CMsgExecuteSqlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsgExecuteSqlRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMsgExecuteSqlRequest& from);
  void MergeFrom(const CMsgExecuteSqlRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgExecuteSqlRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgExecuteSqlRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbmessage_2eproto);
    return ::descriptor_table_dbmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlRequest_Msg Msg;
  static constexpr Msg MsgID =
    CMsgExecuteSqlRequest_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlRequest_Msg_IsValid(value);
  }
  static constexpr Msg Msg_MIN =
    CMsgExecuteSqlRequest_Msg_Msg_MIN;
  static constexpr Msg Msg_MAX =
    CMsgExecuteSqlRequest_Msg_Msg_MAX;
  static constexpr int Msg_ARRAYSIZE =
    CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlRequest_Msg_descriptor();
  }
  template<typename T>
  static inline const std::string& Msg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Msg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Msg_Name.");
    return CMsgExecuteSqlRequest_Msg_Name(enum_t_value);
  }
  static inline bool Msg_Parse(const std::string& name,
      Msg* value) {
    return CMsgExecuteSqlRequest_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string Sql = 7;
  bool has_sql() const;
  void clear_sql();
  static const int kSqlFieldNumber = 7;
  const std::string& sql() const;
  void set_sql(const std::string& value);
  void set_sql(std::string&& value);
  void set_sql(const char* value);
  void set_sql(const char* value, size_t size);
  std::string* mutable_sql();
  std::string* release_sql();
  void set_allocated_sql(std::string* sql);

  // optional bytes Buffer = 9;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 9;
  const std::string& buffer() const;
  void set_buffer(const std::string& value);
  void set_buffer(std::string&& value);
  void set_buffer(const char* value);
  void set_buffer(const void* value, size_t size);
  std::string* mutable_buffer();
  std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);

  // optional string SQLWhere = 10;
  bool has_sqlwhere() const;
  void clear_sqlwhere();
  static const int kSQLWhereFieldNumber = 10;
  const std::string& sqlwhere() const;
  void set_sqlwhere(const std::string& value);
  void set_sqlwhere(std::string&& value);
  void set_sqlwhere(const char* value);
  void set_sqlwhere(const char* value, size_t size);
  std::string* mutable_sqlwhere();
  std::string* release_sqlwhere();
  void set_allocated_sqlwhere(std::string* sqlwhere);

  // optional uint32 LogicType = 1;
  bool has_logictype() const;
  void clear_logictype();
  static const int kLogicTypeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 logictype() const;
  void set_logictype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 SessionID = 2 [default = 0];
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 sessionid() const;
  void set_sessionid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 TimeStamp = 3 [default = 0];
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 TeamID = 4 [default = 0];
  bool has_teamid() const;
  void clear_teamid();
  static const int kTeamIDFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 teamid() const;
  void set_teamid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 BufSize = 8 [default = 0];
  bool has_bufsize() const;
  void clear_bufsize();
  static const int kBufSizeFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 bufsize() const;
  void set_bufsize(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 OutNumber = 11 [default = 0];
  bool has_outnumber() const;
  void clear_outnumber();
  static const int kOutNumberFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 outnumber() const;
  void set_outnumber(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .BLOB HasBlob = 12;
  bool has_hasblob() const;
  void clear_hasblob();
  static const int kHasBlobFieldNumber = 12;
  ::BLOB hasblob() const;
  void set_hasblob(::BLOB value);

  // optional .SQLTYPE SqlType = 5 [default = SELECT];
  bool has_sqltype() const;
  void clear_sqltype();
  static const int kSqlTypeFieldNumber = 5;
  ::SQLTYPE sqltype() const;
  void set_sqltype(::SQLTYPE value);

  // optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
  bool has_callback() const;
  void clear_callback();
  static const int kCallbackFieldNumber = 6;
  ::CALLBACK callback() const;
  void set_callback(::CALLBACK value);

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sqlwhere_;
  ::PROTOBUF_NAMESPACE_ID::uint32 logictype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sessionid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 teamid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bufsize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 outnumber_;
  int hasblob_;
  int sqltype_;
  int callback_;
  friend struct ::TableStruct_dbmessage_2eproto;
};
// -------------------------------------------------------------------

class CMsgExecuteSqlResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgExecuteSqlResponse) */ {
 public:
  CMsgExecuteSqlResponse();
  virtual ~CMsgExecuteSqlResponse();

  CMsgExecuteSqlResponse(const CMsgExecuteSqlResponse& from);
  CMsgExecuteSqlResponse(CMsgExecuteSqlResponse&& from) noexcept
    : CMsgExecuteSqlResponse() {
    *this = ::std::move(from);
  }

  inline CMsgExecuteSqlResponse& operator=(const CMsgExecuteSqlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgExecuteSqlResponse& operator=(CMsgExecuteSqlResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CMsgExecuteSqlResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgExecuteSqlResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgExecuteSqlResponse*>(
               &_CMsgExecuteSqlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgExecuteSqlResponse* other);
  friend void swap(CMsgExecuteSqlResponse& a, CMsgExecuteSqlResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgExecuteSqlResponse* New() const final {
    return CreateMaybeMessage<CMsgExecuteSqlResponse>(nullptr);
  }

  CMsgExecuteSqlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsgExecuteSqlResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMsgExecuteSqlResponse& from);
  void MergeFrom(const CMsgExecuteSqlResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgExecuteSqlResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgExecuteSqlResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbmessage_2eproto);
    return ::descriptor_table_dbmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlResponse_Msg Msg;
  static constexpr Msg MsgID =
    CMsgExecuteSqlResponse_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlResponse_Msg_IsValid(value);
  }
  static constexpr Msg Msg_MIN =
    CMsgExecuteSqlResponse_Msg_Msg_MIN;
  static constexpr Msg Msg_MAX =
    CMsgExecuteSqlResponse_Msg_Msg_MAX;
  static constexpr int Msg_ARRAYSIZE =
    CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlResponse_Msg_descriptor();
  }
  template<typename T>
  static inline const std::string& Msg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Msg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Msg_Name.");
    return CMsgExecuteSqlResponse_Msg_Name(enum_t_value);
  }
  static inline bool Msg_Parse(const std::string& name,
      Msg* value) {
    return CMsgExecuteSqlResponse_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes FieldValue = 8;
  int fieldvalue_size() const;
  void clear_fieldvalue();
  static const int kFieldValueFieldNumber = 8;
  const std::string& fieldvalue(int index) const;
  std::string* mutable_fieldvalue(int index);
  void set_fieldvalue(int index, const std::string& value);
  void set_fieldvalue(int index, std::string&& value);
  void set_fieldvalue(int index, const char* value);
  void set_fieldvalue(int index, const void* value, size_t size);
  std::string* add_fieldvalue();
  void add_fieldvalue(const std::string& value);
  void add_fieldvalue(std::string&& value);
  void add_fieldvalue(const char* value);
  void add_fieldvalue(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fieldvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fieldvalue();

  // repeated uint32 FieldValueLen = 9;
  int fieldvaluelen_size() const;
  void clear_fieldvaluelen();
  static const int kFieldValueLenFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 fieldvaluelen(int index) const;
  void set_fieldvaluelen(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_fieldvaluelen(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      fieldvaluelen() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_fieldvaluelen();

  // optional uint32 LogicType = 1;
  bool has_logictype() const;
  void clear_logictype();
  static const int kLogicTypeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 logictype() const;
  void set_logictype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 SessionID = 2;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 sessionid() const;
  void set_sessionid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 TimeStamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 TeamID = 4;
  bool has_teamid() const;
  void clear_teamid();
  static const int kTeamIDFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 teamid() const;
  void set_teamid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 ResultCode = 5;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultCodeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 resultcode() const;
  void set_resultcode(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 RowCount = 6 [default = 0];
  bool has_rowcount() const;
  void clear_rowcount();
  static const int kRowCountFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 rowcount() const;
  void set_rowcount(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 ColCount = 7 [default = 0];
  bool has_colcount() const;
  void clear_colcount();
  static const int kColCountFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 colcount() const;
  void set_colcount(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fieldvalue_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > fieldvaluelen_;
  ::PROTOBUF_NAMESPACE_ID::uint32 logictype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sessionid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 teamid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 resultcode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rowcount_;
  ::PROTOBUF_NAMESPACE_ID::uint32 colcount_;
  friend struct ::TableStruct_dbmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgExecuteSqlRequest

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlRequest::has_logictype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_logictype() {
  logictype_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlRequest::logictype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.LogicType)
  return logictype_;
}
inline void CMsgExecuteSqlRequest::set_logictype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  logictype_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.LogicType)
}

// optional uint32 SessionID = 2 [default = 0];
inline bool CMsgExecuteSqlRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_sessionid() {
  sessionid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SessionID)
  return sessionid_;
}
inline void CMsgExecuteSqlRequest::set_sessionid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SessionID)
}

// optional uint64 TimeStamp = 3 [default = 0];
inline bool CMsgExecuteSqlRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CMsgExecuteSqlRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.TimeStamp)
  return timestamp_;
}
inline void CMsgExecuteSqlRequest::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.TimeStamp)
}

// optional uint64 TeamID = 4 [default = 0];
inline bool CMsgExecuteSqlRequest::has_teamid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_teamid() {
  teamid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CMsgExecuteSqlRequest::teamid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.TeamID)
  return teamid_;
}
inline void CMsgExecuteSqlRequest::set_teamid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  teamid_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.TeamID)
}

// optional .SQLTYPE SqlType = 5 [default = SELECT];
inline bool CMsgExecuteSqlRequest::has_sqltype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_sqltype() {
  sqltype_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::SQLTYPE CMsgExecuteSqlRequest::sqltype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SqlType)
  return static_cast< ::SQLTYPE >(sqltype_);
}
inline void CMsgExecuteSqlRequest::set_sqltype(::SQLTYPE value) {
  assert(::SQLTYPE_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  sqltype_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SqlType)
}

// optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
inline bool CMsgExecuteSqlRequest::has_callback() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_callback() {
  callback_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::CALLBACK CMsgExecuteSqlRequest::callback() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Callback)
  return static_cast< ::CALLBACK >(callback_);
}
inline void CMsgExecuteSqlRequest::set_callback(::CALLBACK value) {
  assert(::CALLBACK_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  callback_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Callback)
}

// optional string Sql = 7;
inline bool CMsgExecuteSqlRequest::has_sql() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_sql() {
  sql_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgExecuteSqlRequest::sql() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Sql)
  return sql_.GetNoArena();
}
inline void CMsgExecuteSqlRequest::set_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sql_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Sql)
}
inline void CMsgExecuteSqlRequest::set_sql(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sql_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CMsgExecuteSqlRequest.Sql)
}
inline void CMsgExecuteSqlRequest::set_sql(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sql_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CMsgExecuteSqlRequest.Sql)
}
inline void CMsgExecuteSqlRequest::set_sql(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sql_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CMsgExecuteSqlRequest.Sql)
}
inline std::string* CMsgExecuteSqlRequest::mutable_sql() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.Sql)
  return sql_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMsgExecuteSqlRequest::release_sql() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.Sql)
  if (!has_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sql_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgExecuteSqlRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sql_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sql);
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.Sql)
}

// optional uint32 BufSize = 8 [default = 0];
inline bool CMsgExecuteSqlRequest::has_bufsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_bufsize() {
  bufsize_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlRequest::bufsize() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.BufSize)
  return bufsize_;
}
inline void CMsgExecuteSqlRequest::set_bufsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  bufsize_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.BufSize)
}

// optional bytes Buffer = 9;
inline bool CMsgExecuteSqlRequest::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_buffer() {
  buffer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgExecuteSqlRequest::buffer() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.Buffer)
  return buffer_.GetNoArena();
}
inline void CMsgExecuteSqlRequest::set_buffer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  buffer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.Buffer)
}
inline void CMsgExecuteSqlRequest::set_buffer(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  buffer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CMsgExecuteSqlRequest.Buffer)
}
inline void CMsgExecuteSqlRequest::set_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  buffer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CMsgExecuteSqlRequest.Buffer)
}
inline void CMsgExecuteSqlRequest::set_buffer(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  buffer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CMsgExecuteSqlRequest.Buffer)
}
inline std::string* CMsgExecuteSqlRequest::mutable_buffer() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.Buffer)
  return buffer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMsgExecuteSqlRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.Buffer)
  if (!has_buffer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return buffer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgExecuteSqlRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  buffer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer);
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.Buffer)
}

// optional string SQLWhere = 10;
inline bool CMsgExecuteSqlRequest::has_sqlwhere() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_sqlwhere() {
  sqlwhere_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgExecuteSqlRequest::sqlwhere() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.SQLWhere)
  return sqlwhere_.GetNoArena();
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sqlwhere_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.SQLWhere)
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  sqlwhere_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CMsgExecuteSqlRequest.SQLWhere)
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  sqlwhere_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CMsgExecuteSqlRequest.SQLWhere)
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  sqlwhere_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CMsgExecuteSqlRequest.SQLWhere)
}
inline std::string* CMsgExecuteSqlRequest::mutable_sqlwhere() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlRequest.SQLWhere)
  return sqlwhere_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMsgExecuteSqlRequest::release_sqlwhere() {
  // @@protoc_insertion_point(field_release:CMsgExecuteSqlRequest.SQLWhere)
  if (!has_sqlwhere()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sqlwhere_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgExecuteSqlRequest::set_allocated_sqlwhere(std::string* sqlwhere) {
  if (sqlwhere != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sqlwhere_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sqlwhere);
  // @@protoc_insertion_point(field_set_allocated:CMsgExecuteSqlRequest.SQLWhere)
}

// optional uint32 OutNumber = 11 [default = 0];
inline bool CMsgExecuteSqlRequest::has_outnumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_outnumber() {
  outnumber_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlRequest::outnumber() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.OutNumber)
  return outnumber_;
}
inline void CMsgExecuteSqlRequest::set_outnumber(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  outnumber_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.OutNumber)
}

// optional .BLOB HasBlob = 12;
inline bool CMsgExecuteSqlRequest::has_hasblob() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgExecuteSqlRequest::clear_hasblob() {
  hasblob_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::BLOB CMsgExecuteSqlRequest::hasblob() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlRequest.HasBlob)
  return static_cast< ::BLOB >(hasblob_);
}
inline void CMsgExecuteSqlRequest::set_hasblob(::BLOB value) {
  assert(::BLOB_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  hasblob_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlRequest.HasBlob)
}

// -------------------------------------------------------------------

// CMsgExecuteSqlResponse

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlResponse::has_logictype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_logictype() {
  logictype_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::logictype() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.LogicType)
  return logictype_;
}
inline void CMsgExecuteSqlResponse::set_logictype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  logictype_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.LogicType)
}

// optional uint32 SessionID = 2;
inline bool CMsgExecuteSqlResponse::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_sessionid() {
  sessionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.SessionID)
  return sessionid_;
}
inline void CMsgExecuteSqlResponse::set_sessionid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.SessionID)
}

// optional uint64 TimeStamp = 3;
inline bool CMsgExecuteSqlResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CMsgExecuteSqlResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.TimeStamp)
  return timestamp_;
}
inline void CMsgExecuteSqlResponse::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.TimeStamp)
}

// optional uint64 TeamID = 4;
inline bool CMsgExecuteSqlResponse::has_teamid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_teamid() {
  teamid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CMsgExecuteSqlResponse::teamid() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.TeamID)
  return teamid_;
}
inline void CMsgExecuteSqlResponse::set_teamid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  teamid_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.TeamID)
}

// optional uint32 ResultCode = 5;
inline bool CMsgExecuteSqlResponse::has_resultcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_resultcode() {
  resultcode_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::resultcode() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.ResultCode)
  return resultcode_;
}
inline void CMsgExecuteSqlResponse::set_resultcode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.ResultCode)
}

// optional uint32 RowCount = 6 [default = 0];
inline bool CMsgExecuteSqlResponse::has_rowcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_rowcount() {
  rowcount_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::rowcount() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.RowCount)
  return rowcount_;
}
inline void CMsgExecuteSqlResponse::set_rowcount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  rowcount_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.RowCount)
}

// optional uint32 ColCount = 7 [default = 0];
inline bool CMsgExecuteSqlResponse::has_colcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgExecuteSqlResponse::clear_colcount() {
  colcount_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::colcount() const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.ColCount)
  return colcount_;
}
inline void CMsgExecuteSqlResponse::set_colcount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  colcount_ = value;
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.ColCount)
}

// repeated bytes FieldValue = 8;
inline int CMsgExecuteSqlResponse::fieldvalue_size() const {
  return fieldvalue_.size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvalue() {
  fieldvalue_.Clear();
}
inline const std::string& CMsgExecuteSqlResponse::fieldvalue(int index) const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_.Get(index);
}
inline std::string* CMsgExecuteSqlResponse::mutable_fieldvalue(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_.Mutable(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValue)
  fieldvalue_.Mutable(index)->assign(value);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValue)
  fieldvalue_.Mutable(index)->assign(std::move(value));
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fieldvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const void* value, size_t size) {
  fieldvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgExecuteSqlResponse.FieldValue)
}
inline std::string* CMsgExecuteSqlResponse::add_fieldvalue() {
  // @@protoc_insertion_point(field_add_mutable:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_.Add();
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const std::string& value) {
  fieldvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(std::string&& value) {
  fieldvalue_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fieldvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CMsgExecuteSqlResponse.FieldValue)
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const void* value, size_t size) {
  fieldvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CMsgExecuteSqlResponse.FieldValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CMsgExecuteSqlResponse::fieldvalue() const {
  // @@protoc_insertion_point(field_list:CMsgExecuteSqlResponse.FieldValue)
  return fieldvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CMsgExecuteSqlResponse::mutable_fieldvalue() {
  // @@protoc_insertion_point(field_mutable_list:CMsgExecuteSqlResponse.FieldValue)
  return &fieldvalue_;
}

// repeated uint32 FieldValueLen = 9;
inline int CMsgExecuteSqlResponse::fieldvaluelen_size() const {
  return fieldvaluelen_.size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvaluelen() {
  fieldvaluelen_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CMsgExecuteSqlResponse::fieldvaluelen(int index) const {
  // @@protoc_insertion_point(field_get:CMsgExecuteSqlResponse.FieldValueLen)
  return fieldvaluelen_.Get(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvaluelen(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  fieldvaluelen_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgExecuteSqlResponse.FieldValueLen)
}
inline void CMsgExecuteSqlResponse::add_fieldvaluelen(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  fieldvaluelen_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgExecuteSqlResponse.FieldValueLen)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
CMsgExecuteSqlResponse::fieldvaluelen() const {
  // @@protoc_insertion_point(field_list:CMsgExecuteSqlResponse.FieldValueLen)
  return fieldvaluelen_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
CMsgExecuteSqlResponse::mutable_fieldvaluelen() {
  // @@protoc_insertion_point(field_mutable_list:CMsgExecuteSqlResponse.FieldValueLen)
  return &fieldvaluelen_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgExecuteSqlRequest_Msg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlRequest_Msg>() {
  return ::CMsgExecuteSqlRequest_Msg_descriptor();
}
template <> struct is_proto_enum< ::CMsgExecuteSqlResponse_Msg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlResponse_Msg>() {
  return ::CMsgExecuteSqlResponse_Msg_descriptor();
}
template <> struct is_proto_enum< ::SQLTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SQLTYPE>() {
  return ::SQLTYPE_descriptor();
}
template <> struct is_proto_enum< ::CALLBACK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CALLBACK>() {
  return ::CALLBACK_descriptor();
}
template <> struct is_proto_enum< ::BLOB> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BLOB>() {
  return ::BLOB_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dbmessage_2eproto
