// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbmessage.proto

#ifndef PROTOBUF_dbmessage_2eproto__INCLUDED
#define PROTOBUF_dbmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dbmessage_2eproto();
void protobuf_AssignDesc_dbmessage_2eproto();
void protobuf_ShutdownFile_dbmessage_2eproto();

class CMsgExecuteSqlRequest;
class CMsgExecuteSqlResponse;

enum CMsgExecuteSqlRequest_Msg {
  CMsgExecuteSqlRequest_Msg_MsgID = 65537
};
bool CMsgExecuteSqlRequest_Msg_IsValid(int value);
const CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MIN = CMsgExecuteSqlRequest_Msg_MsgID;
const CMsgExecuteSqlRequest_Msg CMsgExecuteSqlRequest_Msg_Msg_MAX = CMsgExecuteSqlRequest_Msg_MsgID;
const int CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlRequest_Msg_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgExecuteSqlRequest_Msg_descriptor();
inline const ::std::string& CMsgExecuteSqlRequest_Msg_Name(CMsgExecuteSqlRequest_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgExecuteSqlRequest_Msg_descriptor(), value);
}
inline bool CMsgExecuteSqlRequest_Msg_Parse(
    const ::std::string& name, CMsgExecuteSqlRequest_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgExecuteSqlRequest_Msg>(
    CMsgExecuteSqlRequest_Msg_descriptor(), name, value);
}
enum CMsgExecuteSqlResponse_Msg {
  CMsgExecuteSqlResponse_Msg_MsgID = 65538
};
bool CMsgExecuteSqlResponse_Msg_IsValid(int value);
const CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MIN = CMsgExecuteSqlResponse_Msg_MsgID;
const CMsgExecuteSqlResponse_Msg CMsgExecuteSqlResponse_Msg_Msg_MAX = CMsgExecuteSqlResponse_Msg_MsgID;
const int CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE = CMsgExecuteSqlResponse_Msg_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgExecuteSqlResponse_Msg_descriptor();
inline const ::std::string& CMsgExecuteSqlResponse_Msg_Name(CMsgExecuteSqlResponse_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgExecuteSqlResponse_Msg_descriptor(), value);
}
inline bool CMsgExecuteSqlResponse_Msg_Parse(
    const ::std::string& name, CMsgExecuteSqlResponse_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgExecuteSqlResponse_Msg>(
    CMsgExecuteSqlResponse_Msg_descriptor(), name, value);
}
enum SQLTYPE {
  SELECT = 1,
  INSERT = 2,
  UPDATE = 3,
  DELETE = 4,
  CALL = 5
};
bool SQLTYPE_IsValid(int value);
const SQLTYPE SQLTYPE_MIN = SELECT;
const SQLTYPE SQLTYPE_MAX = CALL;
const int SQLTYPE_ARRAYSIZE = SQLTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SQLTYPE_descriptor();
inline const ::std::string& SQLTYPE_Name(SQLTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SQLTYPE_descriptor(), value);
}
inline bool SQLTYPE_Parse(
    const ::std::string& name, SQLTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SQLTYPE>(
    SQLTYPE_descriptor(), name, value);
}
enum CALLBACK {
  MUSTCALLBACK = 1,
  NOTCALLBACK = 2
};
bool CALLBACK_IsValid(int value);
const CALLBACK CALLBACK_MIN = MUSTCALLBACK;
const CALLBACK CALLBACK_MAX = NOTCALLBACK;
const int CALLBACK_ARRAYSIZE = CALLBACK_MAX + 1;

const ::google::protobuf::EnumDescriptor* CALLBACK_descriptor();
inline const ::std::string& CALLBACK_Name(CALLBACK value) {
  return ::google::protobuf::internal::NameOfEnum(
    CALLBACK_descriptor(), value);
}
inline bool CALLBACK_Parse(
    const ::std::string& name, CALLBACK* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CALLBACK>(
    CALLBACK_descriptor(), name, value);
}
enum BLOB {
  HASBLOB = 1,
  NONEBLOB = 2
};
bool BLOB_IsValid(int value);
const BLOB BLOB_MIN = HASBLOB;
const BLOB BLOB_MAX = NONEBLOB;
const int BLOB_ARRAYSIZE = BLOB_MAX + 1;

const ::google::protobuf::EnumDescriptor* BLOB_descriptor();
inline const ::std::string& BLOB_Name(BLOB value) {
  return ::google::protobuf::internal::NameOfEnum(
    BLOB_descriptor(), value);
}
inline bool BLOB_Parse(
    const ::std::string& name, BLOB* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BLOB>(
    BLOB_descriptor(), name, value);
}
// ===================================================================

class CMsgExecuteSqlRequest : public ::google::protobuf::Message {
 public:
  CMsgExecuteSqlRequest();
  virtual ~CMsgExecuteSqlRequest();

  CMsgExecuteSqlRequest(const CMsgExecuteSqlRequest& from);

  inline CMsgExecuteSqlRequest& operator=(const CMsgExecuteSqlRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgExecuteSqlRequest& default_instance();

  void Swap(CMsgExecuteSqlRequest* other);

  // implements Message ----------------------------------------------

  CMsgExecuteSqlRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgExecuteSqlRequest& from);
  void MergeFrom(const CMsgExecuteSqlRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlRequest_Msg Msg;
  static const Msg MsgID = CMsgExecuteSqlRequest_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlRequest_Msg_IsValid(value);
  }
  static const Msg Msg_MIN =
    CMsgExecuteSqlRequest_Msg_Msg_MIN;
  static const Msg Msg_MAX =
    CMsgExecuteSqlRequest_Msg_Msg_MAX;
  static const int Msg_ARRAYSIZE =
    CMsgExecuteSqlRequest_Msg_Msg_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlRequest_Msg_descriptor();
  }
  static inline const ::std::string& Msg_Name(Msg value) {
    return CMsgExecuteSqlRequest_Msg_Name(value);
  }
  static inline bool Msg_Parse(const ::std::string& name,
      Msg* value) {
    return CMsgExecuteSqlRequest_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 LogicType = 1;
  inline bool has_logictype() const;
  inline void clear_logictype();
  static const int kLogicTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 logictype() const;
  inline void set_logictype(::google::protobuf::uint32 value);

  // optional uint32 SessionID = 2 [default = 0];
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 2;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional uint64 TimeStamp = 3 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional uint64 TeamID = 4 [default = 0];
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIDFieldNumber = 4;
  inline ::google::protobuf::uint64 teamid() const;
  inline void set_teamid(::google::protobuf::uint64 value);

  // optional .SQLTYPE SqlType = 5 [default = SELECT];
  inline bool has_sqltype() const;
  inline void clear_sqltype();
  static const int kSqlTypeFieldNumber = 5;
  inline ::SQLTYPE sqltype() const;
  inline void set_sqltype(::SQLTYPE value);

  // optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
  inline bool has_callback() const;
  inline void clear_callback();
  static const int kCallbackFieldNumber = 6;
  inline ::CALLBACK callback() const;
  inline void set_callback(::CALLBACK value);

  // optional string Sql = 7;
  inline bool has_sql() const;
  inline void clear_sql();
  static const int kSqlFieldNumber = 7;
  inline const ::std::string& sql() const;
  inline void set_sql(const ::std::string& value);
  inline void set_sql(const char* value);
  inline void set_sql(const char* value, size_t size);
  inline ::std::string* mutable_sql();
  inline ::std::string* release_sql();
  inline void set_allocated_sql(::std::string* sql);

  // optional uint32 BufSize = 8 [default = 0];
  inline bool has_bufsize() const;
  inline void clear_bufsize();
  static const int kBufSizeFieldNumber = 8;
  inline ::google::protobuf::uint32 bufsize() const;
  inline void set_bufsize(::google::protobuf::uint32 value);

  // optional bytes Buffer = 9;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 9;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // optional string SQLWhere = 10;
  inline bool has_sqlwhere() const;
  inline void clear_sqlwhere();
  static const int kSQLWhereFieldNumber = 10;
  inline const ::std::string& sqlwhere() const;
  inline void set_sqlwhere(const ::std::string& value);
  inline void set_sqlwhere(const char* value);
  inline void set_sqlwhere(const char* value, size_t size);
  inline ::std::string* mutable_sqlwhere();
  inline ::std::string* release_sqlwhere();
  inline void set_allocated_sqlwhere(::std::string* sqlwhere);

  // optional uint32 OutNumber = 11 [default = 0];
  inline bool has_outnumber() const;
  inline void clear_outnumber();
  static const int kOutNumberFieldNumber = 11;
  inline ::google::protobuf::uint32 outnumber() const;
  inline void set_outnumber(::google::protobuf::uint32 value);

  // optional .BLOB HasBlob = 12;
  inline bool has_hasblob() const;
  inline void clear_hasblob();
  static const int kHasBlobFieldNumber = 12;
  inline ::BLOB hasblob() const;
  inline void set_hasblob(::BLOB value);

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlRequest)
 private:
  inline void set_has_logictype();
  inline void clear_has_logictype();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_sqltype();
  inline void clear_has_sqltype();
  inline void set_has_callback();
  inline void clear_has_callback();
  inline void set_has_sql();
  inline void clear_has_sql();
  inline void set_has_bufsize();
  inline void clear_has_bufsize();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  inline void set_has_sqlwhere();
  inline void clear_has_sqlwhere();
  inline void set_has_outnumber();
  inline void clear_has_outnumber();
  inline void set_has_hasblob();
  inline void clear_has_hasblob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 logictype_;
  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 teamid_;
  int sqltype_;
  int callback_;
  ::std::string* sql_;
  ::std::string* buffer_;
  ::google::protobuf::uint32 bufsize_;
  ::google::protobuf::uint32 outnumber_;
  ::std::string* sqlwhere_;
  int hasblob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_dbmessage_2eproto();
  friend void protobuf_AssignDesc_dbmessage_2eproto();
  friend void protobuf_ShutdownFile_dbmessage_2eproto();

  void InitAsDefaultInstance();
  static CMsgExecuteSqlRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgExecuteSqlResponse : public ::google::protobuf::Message {
 public:
  CMsgExecuteSqlResponse();
  virtual ~CMsgExecuteSqlResponse();

  CMsgExecuteSqlResponse(const CMsgExecuteSqlResponse& from);

  inline CMsgExecuteSqlResponse& operator=(const CMsgExecuteSqlResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgExecuteSqlResponse& default_instance();

  void Swap(CMsgExecuteSqlResponse* other);

  // implements Message ----------------------------------------------

  CMsgExecuteSqlResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgExecuteSqlResponse& from);
  void MergeFrom(const CMsgExecuteSqlResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgExecuteSqlResponse_Msg Msg;
  static const Msg MsgID = CMsgExecuteSqlResponse_Msg_MsgID;
  static inline bool Msg_IsValid(int value) {
    return CMsgExecuteSqlResponse_Msg_IsValid(value);
  }
  static const Msg Msg_MIN =
    CMsgExecuteSqlResponse_Msg_Msg_MIN;
  static const Msg Msg_MAX =
    CMsgExecuteSqlResponse_Msg_Msg_MAX;
  static const int Msg_ARRAYSIZE =
    CMsgExecuteSqlResponse_Msg_Msg_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Msg_descriptor() {
    return CMsgExecuteSqlResponse_Msg_descriptor();
  }
  static inline const ::std::string& Msg_Name(Msg value) {
    return CMsgExecuteSqlResponse_Msg_Name(value);
  }
  static inline bool Msg_Parse(const ::std::string& name,
      Msg* value) {
    return CMsgExecuteSqlResponse_Msg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 LogicType = 1;
  inline bool has_logictype() const;
  inline void clear_logictype();
  static const int kLogicTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 logictype() const;
  inline void set_logictype(::google::protobuf::uint32 value);

  // optional uint32 SessionID = 2;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 2;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional uint64 TimeStamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional uint64 TeamID = 4;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIDFieldNumber = 4;
  inline ::google::protobuf::uint64 teamid() const;
  inline void set_teamid(::google::protobuf::uint64 value);

  // optional uint32 ResultCode = 5;
  inline bool has_resultcode() const;
  inline void clear_resultcode();
  static const int kResultCodeFieldNumber = 5;
  inline ::google::protobuf::uint32 resultcode() const;
  inline void set_resultcode(::google::protobuf::uint32 value);

  // optional uint32 RowCount = 6 [default = 0];
  inline bool has_rowcount() const;
  inline void clear_rowcount();
  static const int kRowCountFieldNumber = 6;
  inline ::google::protobuf::uint32 rowcount() const;
  inline void set_rowcount(::google::protobuf::uint32 value);

  // optional uint32 ColCount = 7 [default = 0];
  inline bool has_colcount() const;
  inline void clear_colcount();
  static const int kColCountFieldNumber = 7;
  inline ::google::protobuf::uint32 colcount() const;
  inline void set_colcount(::google::protobuf::uint32 value);

  // repeated bytes FieldValue = 8;
  inline int fieldvalue_size() const;
  inline void clear_fieldvalue();
  static const int kFieldValueFieldNumber = 8;
  inline const ::std::string& fieldvalue(int index) const;
  inline ::std::string* mutable_fieldvalue(int index);
  inline void set_fieldvalue(int index, const ::std::string& value);
  inline void set_fieldvalue(int index, const char* value);
  inline void set_fieldvalue(int index, const void* value, size_t size);
  inline ::std::string* add_fieldvalue();
  inline void add_fieldvalue(const ::std::string& value);
  inline void add_fieldvalue(const char* value);
  inline void add_fieldvalue(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fieldvalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fieldvalue();

  // repeated uint32 FieldValueLen = 9;
  inline int fieldvaluelen_size() const;
  inline void clear_fieldvaluelen();
  static const int kFieldValueLenFieldNumber = 9;
  inline ::google::protobuf::uint32 fieldvaluelen(int index) const;
  inline void set_fieldvaluelen(int index, ::google::protobuf::uint32 value);
  inline void add_fieldvaluelen(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      fieldvaluelen() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_fieldvaluelen();

  // @@protoc_insertion_point(class_scope:CMsgExecuteSqlResponse)
 private:
  inline void set_has_logictype();
  inline void clear_has_logictype();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_resultcode();
  inline void clear_has_resultcode();
  inline void set_has_rowcount();
  inline void clear_has_rowcount();
  inline void set_has_colcount();
  inline void clear_has_colcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 logictype_;
  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 teamid_;
  ::google::protobuf::uint32 resultcode_;
  ::google::protobuf::uint32 rowcount_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fieldvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > fieldvaluelen_;
  ::google::protobuf::uint32 colcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_dbmessage_2eproto();
  friend void protobuf_AssignDesc_dbmessage_2eproto();
  friend void protobuf_ShutdownFile_dbmessage_2eproto();

  void InitAsDefaultInstance();
  static CMsgExecuteSqlResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// CMsgExecuteSqlRequest

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlRequest::has_logictype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_logictype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgExecuteSqlRequest::clear_has_logictype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgExecuteSqlRequest::clear_logictype() {
  logictype_ = 0u;
  clear_has_logictype();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlRequest::logictype() const {
  return logictype_;
}
inline void CMsgExecuteSqlRequest::set_logictype(::google::protobuf::uint32 value) {
  set_has_logictype();
  logictype_ = value;
}

// optional uint32 SessionID = 2 [default = 0];
inline bool CMsgExecuteSqlRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgExecuteSqlRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgExecuteSqlRequest::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlRequest::sessionid() const {
  return sessionid_;
}
inline void CMsgExecuteSqlRequest::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint64 TimeStamp = 3 [default = 0];
inline bool CMsgExecuteSqlRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgExecuteSqlRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgExecuteSqlRequest::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 CMsgExecuteSqlRequest::timestamp() const {
  return timestamp_;
}
inline void CMsgExecuteSqlRequest::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint64 TeamID = 4 [default = 0];
inline bool CMsgExecuteSqlRequest::has_teamid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_teamid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgExecuteSqlRequest::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgExecuteSqlRequest::clear_teamid() {
  teamid_ = GOOGLE_ULONGLONG(0);
  clear_has_teamid();
}
inline ::google::protobuf::uint64 CMsgExecuteSqlRequest::teamid() const {
  return teamid_;
}
inline void CMsgExecuteSqlRequest::set_teamid(::google::protobuf::uint64 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional .SQLTYPE SqlType = 5 [default = SELECT];
inline bool CMsgExecuteSqlRequest::has_sqltype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_sqltype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgExecuteSqlRequest::clear_has_sqltype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgExecuteSqlRequest::clear_sqltype() {
  sqltype_ = 1;
  clear_has_sqltype();
}
inline ::SQLTYPE CMsgExecuteSqlRequest::sqltype() const {
  return static_cast< ::SQLTYPE >(sqltype_);
}
inline void CMsgExecuteSqlRequest::set_sqltype(::SQLTYPE value) {
  assert(::SQLTYPE_IsValid(value));
  set_has_sqltype();
  sqltype_ = value;
}

// optional .CALLBACK Callback = 6 [default = MUSTCALLBACK];
inline bool CMsgExecuteSqlRequest::has_callback() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_callback() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgExecuteSqlRequest::clear_has_callback() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgExecuteSqlRequest::clear_callback() {
  callback_ = 1;
  clear_has_callback();
}
inline ::CALLBACK CMsgExecuteSqlRequest::callback() const {
  return static_cast< ::CALLBACK >(callback_);
}
inline void CMsgExecuteSqlRequest::set_callback(::CALLBACK value) {
  assert(::CALLBACK_IsValid(value));
  set_has_callback();
  callback_ = value;
}

// optional string Sql = 7;
inline bool CMsgExecuteSqlRequest::has_sql() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_sql() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgExecuteSqlRequest::clear_has_sql() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgExecuteSqlRequest::clear_sql() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    sql_->clear();
  }
  clear_has_sql();
}
inline const ::std::string& CMsgExecuteSqlRequest::sql() const {
  return *sql_;
}
inline void CMsgExecuteSqlRequest::set_sql(const ::std::string& value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_sql(const char* value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_sql(const char* value, size_t size) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgExecuteSqlRequest::mutable_sql() {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  return sql_;
}
inline ::std::string* CMsgExecuteSqlRequest::release_sql() {
  clear_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_;
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgExecuteSqlRequest::set_allocated_sql(::std::string* sql) {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_;
  }
  if (sql) {
    set_has_sql();
    sql_ = sql;
  } else {
    clear_has_sql();
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BufSize = 8 [default = 0];
inline bool CMsgExecuteSqlRequest::has_bufsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_bufsize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgExecuteSqlRequest::clear_has_bufsize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgExecuteSqlRequest::clear_bufsize() {
  bufsize_ = 0u;
  clear_has_bufsize();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlRequest::bufsize() const {
  return bufsize_;
}
inline void CMsgExecuteSqlRequest::set_bufsize(::google::protobuf::uint32 value) {
  set_has_bufsize();
  bufsize_ = value;
}

// optional bytes Buffer = 9;
inline bool CMsgExecuteSqlRequest::has_buffer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_buffer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgExecuteSqlRequest::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgExecuteSqlRequest::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CMsgExecuteSqlRequest::buffer() const {
  return *buffer_;
}
inline void CMsgExecuteSqlRequest::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgExecuteSqlRequest::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CMsgExecuteSqlRequest::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgExecuteSqlRequest::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SQLWhere = 10;
inline bool CMsgExecuteSqlRequest::has_sqlwhere() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_sqlwhere() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgExecuteSqlRequest::clear_has_sqlwhere() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgExecuteSqlRequest::clear_sqlwhere() {
  if (sqlwhere_ != &::google::protobuf::internal::kEmptyString) {
    sqlwhere_->clear();
  }
  clear_has_sqlwhere();
}
inline const ::std::string& CMsgExecuteSqlRequest::sqlwhere() const {
  return *sqlwhere_;
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const ::std::string& value) {
  set_has_sqlwhere();
  if (sqlwhere_ == &::google::protobuf::internal::kEmptyString) {
    sqlwhere_ = new ::std::string;
  }
  sqlwhere_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const char* value) {
  set_has_sqlwhere();
  if (sqlwhere_ == &::google::protobuf::internal::kEmptyString) {
    sqlwhere_ = new ::std::string;
  }
  sqlwhere_->assign(value);
}
inline void CMsgExecuteSqlRequest::set_sqlwhere(const char* value, size_t size) {
  set_has_sqlwhere();
  if (sqlwhere_ == &::google::protobuf::internal::kEmptyString) {
    sqlwhere_ = new ::std::string;
  }
  sqlwhere_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgExecuteSqlRequest::mutable_sqlwhere() {
  set_has_sqlwhere();
  if (sqlwhere_ == &::google::protobuf::internal::kEmptyString) {
    sqlwhere_ = new ::std::string;
  }
  return sqlwhere_;
}
inline ::std::string* CMsgExecuteSqlRequest::release_sqlwhere() {
  clear_has_sqlwhere();
  if (sqlwhere_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sqlwhere_;
    sqlwhere_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgExecuteSqlRequest::set_allocated_sqlwhere(::std::string* sqlwhere) {
  if (sqlwhere_ != &::google::protobuf::internal::kEmptyString) {
    delete sqlwhere_;
  }
  if (sqlwhere) {
    set_has_sqlwhere();
    sqlwhere_ = sqlwhere;
  } else {
    clear_has_sqlwhere();
    sqlwhere_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 OutNumber = 11 [default = 0];
inline bool CMsgExecuteSqlRequest::has_outnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_outnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgExecuteSqlRequest::clear_has_outnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgExecuteSqlRequest::clear_outnumber() {
  outnumber_ = 0u;
  clear_has_outnumber();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlRequest::outnumber() const {
  return outnumber_;
}
inline void CMsgExecuteSqlRequest::set_outnumber(::google::protobuf::uint32 value) {
  set_has_outnumber();
  outnumber_ = value;
}

// optional .BLOB HasBlob = 12;
inline bool CMsgExecuteSqlRequest::has_hasblob() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgExecuteSqlRequest::set_has_hasblob() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgExecuteSqlRequest::clear_has_hasblob() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgExecuteSqlRequest::clear_hasblob() {
  hasblob_ = 1;
  clear_has_hasblob();
}
inline ::BLOB CMsgExecuteSqlRequest::hasblob() const {
  return static_cast< ::BLOB >(hasblob_);
}
inline void CMsgExecuteSqlRequest::set_hasblob(::BLOB value) {
  assert(::BLOB_IsValid(value));
  set_has_hasblob();
  hasblob_ = value;
}

// -------------------------------------------------------------------

// CMsgExecuteSqlResponse

// optional uint32 LogicType = 1;
inline bool CMsgExecuteSqlResponse::has_logictype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_logictype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgExecuteSqlResponse::clear_has_logictype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgExecuteSqlResponse::clear_logictype() {
  logictype_ = 0u;
  clear_has_logictype();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::logictype() const {
  return logictype_;
}
inline void CMsgExecuteSqlResponse::set_logictype(::google::protobuf::uint32 value) {
  set_has_logictype();
  logictype_ = value;
}

// optional uint32 SessionID = 2;
inline bool CMsgExecuteSqlResponse::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgExecuteSqlResponse::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgExecuteSqlResponse::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::sessionid() const {
  return sessionid_;
}
inline void CMsgExecuteSqlResponse::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint64 TimeStamp = 3;
inline bool CMsgExecuteSqlResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgExecuteSqlResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgExecuteSqlResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 CMsgExecuteSqlResponse::timestamp() const {
  return timestamp_;
}
inline void CMsgExecuteSqlResponse::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint64 TeamID = 4;
inline bool CMsgExecuteSqlResponse::has_teamid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_teamid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgExecuteSqlResponse::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgExecuteSqlResponse::clear_teamid() {
  teamid_ = GOOGLE_ULONGLONG(0);
  clear_has_teamid();
}
inline ::google::protobuf::uint64 CMsgExecuteSqlResponse::teamid() const {
  return teamid_;
}
inline void CMsgExecuteSqlResponse::set_teamid(::google::protobuf::uint64 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional uint32 ResultCode = 5;
inline bool CMsgExecuteSqlResponse::has_resultcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_resultcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgExecuteSqlResponse::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgExecuteSqlResponse::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::resultcode() const {
  return resultcode_;
}
inline void CMsgExecuteSqlResponse::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
}

// optional uint32 RowCount = 6 [default = 0];
inline bool CMsgExecuteSqlResponse::has_rowcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_rowcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgExecuteSqlResponse::clear_has_rowcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgExecuteSqlResponse::clear_rowcount() {
  rowcount_ = 0u;
  clear_has_rowcount();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::rowcount() const {
  return rowcount_;
}
inline void CMsgExecuteSqlResponse::set_rowcount(::google::protobuf::uint32 value) {
  set_has_rowcount();
  rowcount_ = value;
}

// optional uint32 ColCount = 7 [default = 0];
inline bool CMsgExecuteSqlResponse::has_colcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgExecuteSqlResponse::set_has_colcount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgExecuteSqlResponse::clear_has_colcount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgExecuteSqlResponse::clear_colcount() {
  colcount_ = 0u;
  clear_has_colcount();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::colcount() const {
  return colcount_;
}
inline void CMsgExecuteSqlResponse::set_colcount(::google::protobuf::uint32 value) {
  set_has_colcount();
  colcount_ = value;
}

// repeated bytes FieldValue = 8;
inline int CMsgExecuteSqlResponse::fieldvalue_size() const {
  return fieldvalue_.size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvalue() {
  fieldvalue_.Clear();
}
inline const ::std::string& CMsgExecuteSqlResponse::fieldvalue(int index) const {
  return fieldvalue_.Get(index);
}
inline ::std::string* CMsgExecuteSqlResponse::mutable_fieldvalue(int index) {
  return fieldvalue_.Mutable(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const ::std::string& value) {
  fieldvalue_.Mutable(index)->assign(value);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const char* value) {
  fieldvalue_.Mutable(index)->assign(value);
}
inline void CMsgExecuteSqlResponse::set_fieldvalue(int index, const void* value, size_t size) {
  fieldvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgExecuteSqlResponse::add_fieldvalue() {
  return fieldvalue_.Add();
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const ::std::string& value) {
  fieldvalue_.Add()->assign(value);
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const char* value) {
  fieldvalue_.Add()->assign(value);
}
inline void CMsgExecuteSqlResponse::add_fieldvalue(const void* value, size_t size) {
  fieldvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgExecuteSqlResponse::fieldvalue() const {
  return fieldvalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgExecuteSqlResponse::mutable_fieldvalue() {
  return &fieldvalue_;
}

// repeated uint32 FieldValueLen = 9;
inline int CMsgExecuteSqlResponse::fieldvaluelen_size() const {
  return fieldvaluelen_.size();
}
inline void CMsgExecuteSqlResponse::clear_fieldvaluelen() {
  fieldvaluelen_.Clear();
}
inline ::google::protobuf::uint32 CMsgExecuteSqlResponse::fieldvaluelen(int index) const {
  return fieldvaluelen_.Get(index);
}
inline void CMsgExecuteSqlResponse::set_fieldvaluelen(int index, ::google::protobuf::uint32 value) {
  fieldvaluelen_.Set(index, value);
}
inline void CMsgExecuteSqlResponse::add_fieldvaluelen(::google::protobuf::uint32 value) {
  fieldvaluelen_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgExecuteSqlResponse::fieldvaluelen() const {
  return fieldvaluelen_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgExecuteSqlResponse::mutable_fieldvaluelen() {
  return &fieldvaluelen_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlRequest_Msg>() {
  return ::CMsgExecuteSqlRequest_Msg_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgExecuteSqlResponse_Msg>() {
  return ::CMsgExecuteSqlResponse_Msg_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SQLTYPE>() {
  return ::SQLTYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CALLBACK>() {
  return ::CALLBACK_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BLOB>() {
  return ::BLOB_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dbmessage_2eproto__INCLUDED
